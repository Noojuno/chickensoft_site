"use strict";(self.webpackChunkchickensoft_site=self.webpackChunkchickensoft_site||[]).push([[7575],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),d=c(n),h=o,m=d["".concat(l,".").concat(h)]||d[h]||p[h]||i;return n?a.createElement(m,s(s({ref:t},u),{},{components:n})):a.createElement(m,s({ref:t},u))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var c=2;c<i;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3398:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>f,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));const i={title:"Enjoyable Game Architecture",description:"If we can make building games easier, we can focus on the hard part: designing them.\n",image:"./header.jpg",slug:"game-architecture",keywords:["software architecture","architecture","Godot","C#","game design","game engine","Unity","indie game development","open source","foss","programming language","game development","scripting","performance optimization","syntax comparison","cross-platform","community support","tutorials","game engine features","2D game development","3D game development","game development tips","game programming","game publishing"],authors:["joanna"]},s=void 0,r={permalink:"/blog/game-architecture",source:"@site/blog/2023-12-01-game-architecture/index.md",title:"Enjoyable Game Architecture",description:"If we can make building games easier, we can focus on the hard part: designing them.\n",date:"2023-12-01T00:00:00.000Z",formattedDate:"December 1, 2023",tags:[],readingTime:37.605,hasTruncateMarker:!0,authors:[{name:"Joanna",title:"Founder @ Chickensoft",url:"/authors/joanna",imageURL:"/img/authors/joanna.jpg",key:"joanna"}],frontMatter:{title:"Enjoyable Game Architecture",description:"If we can make building games easier, we can focus on the hard part: designing them.\n",image:"./header.jpg",slug:"game-architecture",keywords:["software architecture","architecture","Godot","C#","game design","game engine","Unity","indie game development","open source","foss","programming language","game development","scripting","performance optimization","syntax comparison","cross-platform","community support","tutorials","game engine features","2D game development","3D game development","game development tips","game programming","game publishing"],authors:["joanna"]},prevItem:{title:"Using Godot with C# in 2024",permalink:"/blog/godot-csharp-2024"},nextItem:{title:"Can Godot Deliver?",permalink:"/blog/godot-delivers"}},l={image:n(5790).Z,authorsImageUrls:[void 0]},c=[{value:"\ud83d\udca1 What Is Software Architecture?",id:"-what-is-software-architecture",level:2},{value:"\ud83c\udf70 Abstraction Layers",id:"-abstraction-layers",level:2},{value:"\ud83c\udfad Visual Layer",id:"-visual-layer",level:3},{value:"\ud83e\udd16 GameLogic Layer",id:"-gamelogic-layer",level:3},{value:"\ud83d\uddbc Visual Game Logic Layer",id:"-visual-game-logic-layer",level:4},{value:"State Management In Practice",id:"state-management-in-practice",level:5},{value:"\ud83c\udfb0 Pure Game Logic Layer",id:"-pure-game-logic-layer",level:4},{value:"The Domain of Chess",id:"the-domain-of-chess",level:5},{value:"Making Repositories",id:"making-repositories",level:5},{value:"How Data Flows in a Game",id:"how-data-flows-in-a-game",level:5},{value:"\ud83d\udcbd Data Layer",id:"-data-layer",level:3},{value:"\ud83d\udc89 Dependency Injection",id:"-dependency-injection",level:2},{value:"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f Simplified Dependencies",id:"\ufe0f-simplified-dependencies",level:3},{value:"\ud83e\uddd1\u200d\ud83d\udd2c Testing",id:"-testing",level:2},{value:"\ud83e\uddea Why Write Unit Tests At All?",id:"-why-write-unit-tests-at-all",level:3},{value:"\ud83d\udd2c Unit Tests In Practice",id:"-unit-tests-in-practice",level:3},{value:"\ud83d\udc81 Testing Tips",id:"-testing-tips",level:3},{value:"\ud83c\udfa8 Understanding Visual Testing",id:"-understanding-visual-testing",level:4},{value:"\ud83d\udc77 Setting Up Testing",id:"-setting-up-testing",level:4},{value:"\ud83e\uddec Two-Phase Initialization",id:"-two-phase-initialization",level:4},{value:"\ud83c\udf32 Faking the Scene Tree",id:"-faking-the-scene-tree",level:4},{value:"\ud83e\udd78 Mocking Dependencies Provided with AutoInject",id:"-mocking-dependencies-provided-with-autoinject",level:4},{value:"\ud83d\uddc2 File Structure and Feature-Based Architecture",id:"-file-structure-and-feature-based-architecture",level:2},{value:"\ud83e\udea2 Preventing Strong Coupling in Features",id:"-preventing-strong-coupling-in-features",level:3},{value:"\ud83c\udfdb File Structure for Tests",id:"-file-structure-for-tests",level:3},{value:"\ud83e\udd70 Conclusion",id:"-conclusion",level:2}],u=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",t)},p=u("FancyImage"),d=u("Spacer"),h=u("YoutubeEmbed"),m=u("GithubCard"),g=u("BlogDiscordInvite"),y={toc:c};function f(e){let{components:t,...i}=e;return(0,o.kt)("wrapper",(0,a.Z)({},y,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(p,{src:n(5432).Z,alt:"Game architecture header image.",mdxType:"FancyImage"}),(0,o.kt)("p",null,"Game architecture, like all software architecture, tends to be neglected or forgotten as a project goes on. Scalable, enjoyable, production codebases are so rare they're almost mythical."),(0,o.kt)("p",null,"It doesn't have to be this way: just because video game development is difficult doesn't mean it has to be painful. You can still achieve a robust software architecture that scales with your game \u2014\xa0even as you rework core systems and make sweeping refactors. Since architecture is based on expert opinions and developer experiences, we'll borrow from the wisdom of other software architectures to create a game architecture that prioritizes an enjoyable developer experience."),(0,o.kt)("p",null,"Over the last few years, I've been making and maintaining over a dozen open source packages for Godot and C#. While leveraging these packages and the opinionated architecture described in this article, I was able to build a 3D platformer demo in just a month or two of spare time. If you're willing to stick around, I'd love to share the methodology, the rationale, and even the demo itself with you."),(0,o.kt)(d,{mdxType:"Spacer"},(0,o.kt)(h,{embedUrl:"https://www.youtube.com/embed/LEethjxNnrw?si=LPGQLn3C2x9hgmPm",mdxType:"YoutubeEmbed"})),(0,o.kt)("p",null,"In the demo, your goal is to collect all the coins hidden in the 3D world. Go ahead and take a quick look at the demo's code on GitHub: if you like the way the code is written, you'll like this article. If you don't, you should write a rebuttal. Either way, I look forward to hearing from you."),(0,o.kt)(d,{mdxType:"Spacer"},(0,o.kt)(m,{profile:"chickensoft-games",repo:"GameDemo",logo:"/img/chickensoft/game_demo.png",mdxType:"GithubCard"})),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Most of the assets used in the demo are free assets created by ",(0,o.kt)("a",{parentName:"p",href:"https://www.gdquest.com/"},"GDQuest")," \u2014 please check them out and support their efforts!")),(0,o.kt)("p",null,"Why am I tackling something as subjective and nebulous as architecture? Because, deep down inside, I believe most of us don't want to bother with architecture. We just want to make our game and have a good time doing it. Unfortunately, if you just start writing code without a second thought, you'll often find that the further you get, the harder it gets."),(0,o.kt)(p,{src:n(938).Z,alt:"Architecture: software engineering's white whale.",mdxType:"FancyImage"},"A spoof of the charts in Martin Fowler's article ",(0,o.kt)("a",{href:"https://martinfowler.com/articles/is-quality-worth-cost.html"},'"Is High Quality Software Worth the Cost?"'),"."),(0,o.kt)("h2",{id:"-what-is-software-architecture"},"\ud83d\udca1 What Is Software Architecture?"),(0,o.kt)("p",null,"You already know, but we'll define it anyways for the sake of completeness."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"A software architecture is a set of rules and practices designed around the developers' goals for their team's code.")),(0,o.kt)("p",null,"Whether or not those practices actually accomplish those goals is another matter entirely."),(0,o.kt)("p",null,"I believe a good architecture is ",(0,o.kt)("strong",{parentName:"p"},"opinionated"),", ",(0,o.kt)("strong",{parentName:"p"},"based on learnings from past projects")," which met the same (or similar) goals, and ",(0,o.kt)("strong",{parentName:"p"},"plays nicely with the development tools")," for your particular stack: i.e., ",(0,o.kt)("em",{parentName:"p"},"a good architecture should provide structure, be based on experience, and be practical to implement"),"."),(0,o.kt)("p",null,"If there's two equally good ways to do something, a good architecture will pick one as the recommended approach. Good architectures embrace collectivism, not individualism. Each feature or component should be implemented similarly to the other features and components. Increasing code-similarity allows developers to ramp up quickly, switch between features with relative ease, and reduces the number of complex details they have to remember."),(0,o.kt)(p,{src:n(826).Z,alt:"Architecture sanity test.",mdxType:"FancyImage"},"When loose coupling is eliminated, a good architecture should probably be a directed, acyclic graph."),(0,o.kt)("p",null,"Below, I've listed some common, high-level goals that a good architecture might be designed around. These goals range from overall organizational practices to annoying details about where files should be placed and how code should be formatted and linted."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Organization"),": Where do I put code and related assets when adding a new feature?"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Development"),": How do I know what code to write to accomplish a feature?"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Testing"),": How do I write tests for my feature?"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Structure"),": How do I get the dependencies my features need?"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Consistency"),": How do I keep my code formatted? (Yes, this is important. If you don't have automatic style enforcement, you can run into problems where your IDE's language server is trying to apply auto-fixes that make your life hard with the style of coding you've chosen.)"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Flexibility"),": What happens when I need to refactor something? An optimal architecture would allow us to overhaul a feature without breaking the other features, enabling us to iterate faster and keep our code flexible.")),(0,o.kt)("p",null,"While the architecture can't hold your hand and give you line-by-line coding instructions (that's the job of the senior developers on your team), it should, at least, give you a good idea of where to start when you first grab that ticket off the backlog."),(0,o.kt)("p",null,"A good architecture should help prevent writer's, er, coder's block when you first start on a new feature. It should take the guesswork out of what should be mundane procedures (like scaffolding out a new view, its state management, and its tests) and turn it into something you can do in your sleep (or automate with some snippets)."),(0,o.kt)("p",null,"To achieve the lofty goals above, we'll create specific, concrete requirements for our architecture that serves our noble goals. Our ideal architecture should\u2026"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Define ",(0,o.kt)("strong",{parentName:"li"},"abstraction layers")," to organize code modules."),(0,o.kt)("li",{parentName:"ol"},"Provide an ",(0,o.kt)("strong",{parentName:"li"},"organization system")," for the files and assets in the codebase."),(0,o.kt)("li",{parentName:"ol"},'Allow each "unit" of code to be ',(0,o.kt)("strong",{parentName:"li"},"tested in isolation"),".")),(0,o.kt)("p",null,"To meet these goals, we'll draw inspiration from a number of existing patterns and architectures, casually incorporating whatever we like."),(0,o.kt)("h2",{id:"-abstraction-layers"},"\ud83c\udf70 Abstraction Layers"),(0,o.kt)("p",null,"Our ideal architecture should provide an opinion about the overall structure of our game. In a typical visual application, you might have the view layer, business logic / domain layer, and the data layer."),(0,o.kt)("p",null,"For games, we can make our own, similar layers. Each layer will correspond to a type of object in our codebase."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Visual Layer")," \u2014 Scripted game engine components. A Unity ",(0,o.kt)("inlineCode",{parentName:"li"},"MonoBehavior")," attached to a game object, a Godot ",(0,o.kt)("inlineCode",{parentName:"li"},"Node")," script class, etc."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"GameLogic Layer"),' \u2014 the meat and potatoes of your game, itself broken into two "sublayers":',(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Visual Game Logic Layer")," \u2014 state machines, behavior trees, or other stateful mechanisms that drive a single game engine component's state."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Pure Game Logic Layer")," \u2014 repository classes that perform game logic that's not specific to any single visual component."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Data Layer"),' \u2014 Various client classes for "lower level" interactions, such as networking and persistent storage.')),(0,o.kt)("p",null,"Together, these 3 abstraction layers allow us to look at our game critically. Most pieces of code should fall into one of those layers nicely."),(0,o.kt)(p,{src:n(653).Z,alt:"Game Architecture Layers of Abstraction",mdxType:"FancyImage"},"The big 3 abstraction layers: visuals, game logic, and data."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Differentiating game logic into visual game logic and pure game logic is an idea reminiscent of the way ",(0,o.kt)("a",{parentName:"p",href:"https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html"},"clean architecture"),' distinguishes between "enterprise-wide business rules" and "application specific business rules."')),(0,o.kt)("p",null,"We'll also introduce an additional stipulation into our architecture: objects in one layer can only be strongly coupled with objects in the layer directly below them. You might recognize this rule from the strict form of ",(0,o.kt)("a",{parentName:"p",href:"https://cs.uwaterloo.ca/~m2nagapp/courses/CS446/1195/Arch_Design_Activity/Layered.pdf"},"layered architecture"),"."),(0,o.kt)("p",null,'Restricting objects to only interacting with objects in the layer directly beneath them prevents sibling dependencies in the same layer (strong coupling), as well as "skipping" layers, which would indicate a design oversight.'),(0,o.kt)("h3",{id:"-visual-layer"},"\ud83c\udfad Visual Layer"),(0,o.kt)("p",null,"Visual components drive the things we see in the game engine. They come in many flavors, but tend to be pretty similar across game engines. In Unity, you'll find ",(0,o.kt)("inlineCode",{parentName:"p"},"MonoBehavior")," components that are applied to GameObjects. In Godot, we subclass a Godot ",(0,o.kt)("inlineCode",{parentName:"p"},"Node")," and attach the script to a scene node. Both of these systems allow us to represent visual components within the engine."),(0,o.kt)(p,{src:n(4602).Z,alt:"Game Engine Visual Components",mdxType:"FancyImage"},"You know, the part you can actually see."),(0,o.kt)("p",null,"Most game developers will reiterate the importance of separating your visual logic from your game logic, citing the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Single-responsibility_principle"},"single responsibility principle")," \u2014 so, how do you do that exactly?"),(0,o.kt)("p",null,"Mechanisms like ",(0,o.kt)("strong",{parentName:"p"},"state machines")," and ",(0,o.kt)("strong",{parentName:"p"},"behavior trees"),' are commonly used to separate the "state" of something from the code that visualizes it. For example, a visual script can create a state machine and provide a reference to itself to the state machine, allowing the state machine to "drive" the visual object as it changes between states. The visual script can likewise hang onto a reference to its state machine, forwarding relevant input events to it, giving the state machine a chance to drive it whenever something happens.'),(0,o.kt)(p,{src:n(8370).Z,alt:"Level being edited in the Godot game engine.",mdxType:"FancyImage"},"Editing a level in the Godot game engine."),(0,o.kt)("p",null,"An optimal architecture would probably eliminate conditional branching from visual game component scripts altogether, performing all logic in the component's state machine or other state mechanism."),(0,o.kt)("p",null,"Real life isn't always so pretty, though: for performance reasons, it's often advantageous to have a few checks in the visual component itself to decide if it's even worth passing an event to the state machine. If you don't, garbage collected languages like C# can generate a lot of unnecessary memory pressure, depending on how carefully you handle input queuing and memory allocation."),(0,o.kt)("p",null,"Below is a minimum example of a visual node script. For the sake of example, it is completely stateless. The only event that can happen \u2014 the main menu button being pressed \u2014 is forwarded via the use of a signal, allowing a stateful ancestor to manipulate this node."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"[Meta(typeof(IAutoNode))]\npublic partial class WinMenu : Control, IWinMenu {\n  public override void _Notification(int what) => this.Notify(what);\n\n  #region Nodes\n  [Node]\n  public IButton MainMenuButton { get; set; } = default!;\n  #endregion Nodes\n\n  #region Signals\n  [Signal]\n  public delegate void MainMenuEventHandler();\n  #endregion Signals\n\n  public void OnReady() => MainMenuButton.Pressed += OnMainMenuPressed;\n\n  public void OnExitTree() => MainMenuButton.Pressed -= OnMainMenuPressed;\n\n  public void OnMainMenuPressed() => EmitSignal(SignalName.MainMenu);\n}\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"You'll often find that many nodes can be stateless, simply signaling when something happens. Stripping as much logic out of the visual layer is beneficial because it allows stateful, parent nodes to manipulate the simpler, stateless nodes. For comparison, Google's cross platform app framework ",(0,o.kt)("a",{parentName:"p",href:"https://flutter.dev/"},"Flutter")," specifically forces you to distinguish between a ",(0,o.kt)("a",{parentName:"p",href:"https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html"},"StatefulWidget")," and a ",(0,o.kt)("a",{parentName:"p",href:"https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html"},"StatelessWidget"),". This same distinction applies to Godot, since they both share a visual, tree-based composition structure.")),(0,o.kt)("p",null,"We'll be making extensive use of the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/Introspection"},"Introspection")," source generator, which lets us inject code into our node classes via ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Mixin"},"mixins"),"."),(0,o.kt)("p",null,"In the example above, the ",(0,o.kt)("inlineCode",{parentName:"p"},"IAutoNode")," mixin enables the ",(0,o.kt)("inlineCode",{parentName:"p"},"WinMenu")," class to connect the ",(0,o.kt)("inlineCode",{parentName:"p"},"MainMenuButton")," property to its corresponding node with the same unique identifier, ",(0,o.kt)("inlineCode",{parentName:"p"},"%MainMenuButton")," in the scene. Little tricks like that help save us a ton of error-prone typing."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"IAutoNode")," mixin comes from ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/AutoInject"},"AutoInject"),", which provides a number of utilities in addition to dependency injection."),(0,o.kt)("h3",{id:"-gamelogic-layer"},"\ud83e\udd16 GameLogic Layer"),(0,o.kt)("p",null,"Game logic simply refers to code that manipulates the game and its mechanics, without having to directly worry about other concerns like how the game is visualized, networked, or persisted."),(0,o.kt)("p",null,"In our architecture, we differentiate between two kinds of game logic. Let's look at each one."),(0,o.kt)("h4",{id:"-visual-game-logic-layer"},"\ud83d\uddbc Visual Game Logic Layer"),(0,o.kt)("p",null,"As mentioned, visual game logic is just code that's specific to a single visual component (state machines, behavior trees, or other stateful mechanisms that belong to a specific visual component)."),(0,o.kt)("p",null,"For visuals that do anything more than just appearing in game, they should probably have a reference to a ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Behavior_tree_(artificial_intelligence,_robotics_and_control)"},"behavior tree"),", ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Finite-state_machine"},"state machine"),", ",(0,o.kt)("a",{parentName:"p",href:"https://statecharts.dev/"},"statechart"),", or other such stateful mechanism that represents their state-of-being."),(0,o.kt)("p",null,'Stateful mechanisms can have be loosely coupled to their owning components via an interface, enabling them to "drive" their visual components by calling methods on them or producing outputs that the visual game component binds to.'),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"The visual component's job is to shut up and look pretty"),". The dumber it is, the better. An ideal visual component will just forward all inputs to its underlying state machine (or whatever it's using)."),(0,o.kt)(p,{src:n(3806).Z,alt:"Game Engine Visual Components",mdxType:"FancyImage"},"You know, the part you can actually see."),(0,o.kt)("h5",{id:"state-management-in-practice"},"State Management In Practice"),(0,o.kt)("p",null,"For some of the more complex visual components in your game, a simple state machine would get out of hand quickly. Most likely, you'll end up using a ",(0,o.kt)("a",{parentName:"p",href:"https://statecharts.dev/"},"statechart"),", a type of hierarchical state machine that can help avoid the pitfalls of ordinary state machines."),(0,o.kt)("p",null,"Fortunately, I've already created an ergonomic, hierarchical state machine implementation called ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/LogicBlocks"},"LogicBlocks")," that allows you to write your states the way you write ordinary C# ",(0,o.kt)("del",{parentName:"p"},"classes")," records. In the game demo, LogicBlocks easily handled the menu transition logic, overall pause mode, player state machine, and every other stateful component."),(0,o.kt)("p",null,"I'd recommend at least considering using LogicBlocks, for the following reasons:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Includes a picture generator that reads your code and helps you visualize it as a UML state diagram."),(0,o.kt)("li",{parentName:"ul"},"Easily testable (abstracts inputs and outputs)."),(0,o.kt)("li",{parentName:"ul"},"No need to define transition tables. It operates more like a ",(0,o.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Moore_machine"},"Moore machine"),", which is a lot more ergonomic than the typical transition-based approach."),(0,o.kt)("li",{parentName:"ul"},"Correctly implements state entrance and exit callbacks for nested states."),(0,o.kt)("li",{parentName:"ul"},"Correctly queues and processes inputs."),(0,o.kt)("li",{parentName:"ul"},"Provides states with a blackboard \u2014 a shared data store."),(0,o.kt)("li",{parentName:"ul"},"Includes an ergonomic binding system that allows you to easily synchronize the visual component with its state."),(0,o.kt)("li",{parentName:"ul"},"LogicBlocks can add input to themselves, allowing them to initiate subsequent state changes.")),(0,o.kt)(p,{src:n(6975).Z,alt:"Player state diagram generated by LogicBlocks.",mdxType:"FancyImage"},"State diagram generated by LogicBlocks for the player in the 3D platformer demo."),(0,o.kt)("p",null,"Below, here's the ",(0,o.kt)("inlineCode",{parentName:"p"},"InGameUILogic")," state machine from the game demo. It's an incredibly simple state machine \u2014 it only has one state that subscribes to the ",(0,o.kt)("inlineCode",{parentName:"p"},"AppRepository")," (see next section for details) and produces outputs whenever the number of coins changes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public partial class InGameUILogic {\n  public record State : StateLogic, IState {\n\n    public State(IContext context) : base(context) {\n      var appRepo = context.Get<IAppRepo>();\n\n      OnEnter<State>((previous) => {\n        appRepo.NumCoinsCollected.Sync += OnNumCoinsCollected;\n        appRepo.NumCoinsAtStart.Sync += OnNumCoinsAtStart;\n      });\n\n      OnExit<State>((next) => {\n        appRepo.NumCoinsCollected.Sync -= OnNumCoinsCollected;\n        appRepo.NumCoinsAtStart.Sync -= OnNumCoinsAtStart;\n      });\n    }\n\n    public void OnNumCoinsCollected(int numCoinsCollected) {\n      Context.Output(new Output.NumCoinsCollectedChanged(numCoinsCollected));\n    }\n\n    public void OnNumCoinsAtStart(int numCoinsAtStart) {\n      Context.Output(new Output.NumCoinsAtStartChanged(numCoinsAtStart));\n    }\n\n  }\n}\n")),(0,o.kt)("p",null,"Meanwhile, the actual Godot Node for the ",(0,o.kt)("inlineCode",{parentName:"p"},"InGameUI")," binds to the state machine's outputs, updating the UI whenever the number of coins changes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'\n[Meta(typeof(IAutoNode))]\npublic partial class InGameUI : Control, IInGameUI {\n\n  // ...\n\n  public void OnResolved() {\n    InGameUIBinding = InGameUILogic.Bind();\n\n    InGameUIBinding\n      .Handle<InGameUILogic.Output.NumCoinsCollectedChanged>(\n        (output) => SetCoinsLabel(\n          output.NumCoinsCollected, AppRepo.NumCoinsAtStart.Value\n        )\n      )\n      .Handle<InGameUILogic.Output.NumCoinsAtStartChanged>(\n        (output) => SetCoinsLabel(\n          AppRepo.NumCoinsCollected.Value, output.NumCoinsAtStart\n        )\n      );\n\n    InGameUILogic.Start();\n  }\n\n  public void SetCoinsLabel(int coins, int totalCoins) {\n    CoinsLabel.Text = $"{coins}/{totalCoins}";\n  }\n\n  // ...\n}\n')),(0,o.kt)("h4",{id:"-pure-game-logic-layer"},"\ud83c\udfb0 Pure Game Logic Layer"),(0,o.kt)("p",null,'"Pure" game logic encompasses the "domain" of your game. Components in the pure game logic layer are typically repositories, which are usually just plain-old C# classes. Repositories are responsible for implementing the rules that compromise your game\'s domain.'),(0,o.kt)("h5",{id:"the-domain-of-chess"},"The Domain of Chess"),(0,o.kt)("p",null,'In chess, the rook can capture any piece in its path if doing so would not put the king in check. The rook must also stop at the location where the capture occurs. The concept of "capturing" is a rule specific to chess, and thereby exists within the "domain" of chess.'),(0,o.kt)("p",null,"Because capturing involves more than just a single chess piece, it can't be implemented cleanly in the visual game logic layer. Instead, the state machine for a rook might realize it's being directed to capture a piece, and then call a repository method to attempt the capture. If the rook is allowed to capture the piece, the repository will perform the capture, firing an event that the newly captured piece would already be subscribed to. The captured piece will remove itself from the board, and the repository can return a success indicator to the rook's state machine."),(0,o.kt)(p,{src:n(393).Z,alt:"Capturing in Chess",mdxType:"FancyImage"},"The rules for capturing pieces falls within the game's domain."),(0,o.kt)("h5",{id:"making-repositories"},"Making Repositories"),(0,o.kt)("p",null,"In the game demo, we have an ",(0,o.kt)("inlineCode",{parentName:"p"},"AppRepository")," that allows us to handle the game logic for the entire app. Since collecting coins affects more than just a single visual component and is responsible for how you win the game, we handle coin collection inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"AppRepository"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"/// <summary>\n/// Pure application game logic repository \u2014\xa0shared between view-specific logic\n/// blocks.\n/// </summary>\npublic class AppRepo : IAppRepo {\n  // ...\n\n  public void StartCoinCollection(ICoin coin) {\n    _coinsBeingCollected++;\n    _numCoinsCollected.OnNext(_numCoinsCollected.Value + 1);\n    CoinCollected?.Invoke();\n  }\n\n  public void OnFinishCoinCollection(ICoin coin) {\n    _coinsBeingCollected--;\n\n    if (\n      _coinsBeingCollected == 0 &&\n      _numCoinsCollected.Value >= _numCoinsAtStart.Value\n    ) {\n      OnGameEnded(GameOverReason.PlayerWon);\n    }\n  }\n\n  // ...\n}\n")),(0,o.kt)("p",null,"We've omitted quite a lot for the sake of brevity, but you probably get the idea: whenever a coin detects a collision with the player, it sends an event to its state machine, which starts the coin collection animation and tells the ",(0,o.kt)("inlineCode",{parentName:"p"},"AppRepository")," that a coin is being collected. When the animation finishes, it tells the ",(0,o.kt)("inlineCode",{parentName:"p"},"AppRepository")," that it's finished being collected."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"AppRepository")," tracks the number of coins that were collected and then fires an event to end the game. Other state machines on other visual components are subscribed to the game-over event, handling cleanup or transitioning to other screens, as needed."),(0,o.kt)("h5",{id:"how-data-flows-in-a-game"},"How Data Flows in a Game"),(0,o.kt)("p",null,"A good state machine, behavior tree, or other state implementation should be able to subscribe to events occurring in repositories, as well as receive events and/or query data from the visual component they belong to."),(0,o.kt)("p",null,"You can think of data flowing ",(0,o.kt)("em",{parentName:"p"},"down into the state")," from the visual component that owns it, and ",(0,o.kt)("em",{parentName:"p"},"bubbling upward from game logic repositories")," that need to broadcast events."),(0,o.kt)(p,{src:n(4105).Z,alt:"Separating game logic from visualization.",mdxType:"FancyImage"},"Data flows down from the visuals via strongly coupled relationships, and bubbles back upwards via reactive mechanisms that promote loose coupling, like C# events, Observers, or other such utilities."),(0,o.kt)("p",null,"If all of this sounds familiar, it's probably because it's a ",(0,o.kt)("a",{parentName:"p",href:"https://reactivex.io/"},"reactive")," (as in ReactiveX, or rx) style of coding. Or maybe you've used an ",(0,o.kt)("a",{parentName:"p",href:"https://dzone.com/articles/design-patterns-event-bus"},"event bus")," \u2014 another type of loosely-coupled, observable system."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"I tend to think of reactive-style code like glue: it's extremely powerful, messy, and gets everywhere \u2014 so use sparingly! If you've ever tried to explain multiple chained event source transformers that zip elements together to a junior programmer, you know just how tricky it is to wrap your head around. It's also tricky for yourself, 6 months in the future.")),(0,o.kt)("p",null,"For the sake of convenience, I use a little reactive utility called ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/Collections#autoprop"},(0,o.kt)("inlineCode",{parentName:"a"},"AutoProp"))," inspired by C#'s built-in events and observers. It's more or less the same API as a C# observer, but with a few tweaks to be more ergonomic."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"  public IAutoProp<bool> MyValue => _myValue; // expose read-only version\n  private readonly AutoProp<bool> _myValue = new AutoProp<bool>(false);\n")),(0,o.kt)("p",null,"To keep things sane, we can create feature-specific game repositories. These repositories can be provided to any game component's state mechanism, allowing it to subscribe to the events offered by that repository. Since the visual game logic layer exists directly above the pure game logic layer, only state mechanisms will be allowed to interact with and subscribe to repositories."),(0,o.kt)("h3",{id:"-data-layer"},"\ud83d\udcbd Data Layer"),(0,o.kt)("p",null,"The data layer represents various data clients in your application, like your network client or file client. In many cases, the game engine itself can suffice."),(0,o.kt)("p",null,"Because the data layer is the lowest layer of the application, repositories in the domain layer (your pure game logic) usually invoke various methods on the data layer to send and receive what they need through various channels. Like state machines subscribing to repositories, repositories can themselves subscribe to incoming data from the data layers, invoking their own events when something relevant in the game occurs, allowing all the relevant state machines to receive updates, which in turn updates their visual components. It's turtles all the way up."),(0,o.kt)("p",null,"I didn't implement a game saving or loading in the game demo, so I don't have an example to show just yet. The next Chickensoft package I'm working on will hopefully help reduce the workload of implementing versioned game save systems, so hang tight."),(0,o.kt)("h2",{id:"-dependency-injection"},"\ud83d\udc89 Dependency Injection"),(0,o.kt)("p",null,"Once you know about all the things you'll need, you have to figure out how to get it. We know our app is going to consist of visual components, state management mechanisms, repositories, and data clients."),(0,o.kt)(p,{src:n(5104).Z,alt:"Tree-based dependency provisioning",mdxType:"FancyImage"},"Since Godot is a tree-based system, we can make nodes provide values to their descendant nodes."),(0,o.kt)("p",null,"In the real world, references to objects will trickle downward through each layer of abstraction until they settle into the right place. We're following the \"objects in one layer shouldn't know about any other objects except those in the layer directly below them\" rule from layered architecture, but once again, the real world isn't quite so squeaky clean."),(0,o.kt)("p",null,"In reality, here's how it actually works."),(0,o.kt)("p",null,"A godot node script can provide a value to its descendants. In our game demo, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Player")," node script provides the its logic block, ",(0,o.kt)("inlineCode",{parentName:"p"},"PlayerLogic"),", to its descendant nodes, allowing them to bind to its state machine."),(0,o.kt)("p",null,"To get this value for the first time, though, each descendant will need to search their ancestors to see if any of them provide the type of value they're looking for."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"In all but the deepest trees, doing an ancestor walk is a very quick way to resolve a dependency provider. Deeper trees can re-provide the value to lower sections, reducing search distances.")),(0,o.kt)("p",null,"There's another problem, though. In Godot, the deepest nodes are \"readied\" up before their ancestors. This means that the dependent nodes are asking their ancestor provider nodes for values that the providers haven't necessarily had a chance to initialize."),(0,o.kt)("p",null,"We solve this problem using ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/AutoInject"},"AutoInject"),", which itself leverages the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/Introspection"},"Introspection")," source generator. Under the hood, AutoInject temporarily subscribes to providers for the values it needs. Once the providers have indicated all their dependencies are good to go, AutoInject will make sure the dependent nodes have a chance to set themselves up. If providers immediately provide their values as soon as they're ready (and they should), all of this can happen in the same frame, making everything nice and deterministic."),(0,o.kt)("p",null,"To provide a value using AutoInject, our Player node simply needs to implement ",(0,o.kt)("inlineCode",{parentName:"p"},"IProvide<T>")," for all of the value types it wants to provide."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"[Meta(typeof(IAutoNode))]\npublic partial class Player : CharacterBody3D, IPlayer, IProvide<IPlayerLogic> {\n  public override void _Notification(int what) => this.Notify(what);\n\n  #region Provisions\n  IPlayerLogic IProvide<IPlayerLogic>.Value() => PlayerLogic;\n  #endregion Provisions\n\n  // ...\n\n  public void OnReady() {\n    PlayerLogic = new PlayerLogic(/* ... */);\n\n    Provide(); // Indicate the dependencies we provide are now available.\n  }\n\n}\n")),(0,o.kt)("p",null,"A descendant can just as easily access a dependency from an ancestor node by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"[Dependency]")," attribute on a property."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"PlayerModel")," node, which is a descendant of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Player")," node, binds to the player state machine and triggers visual animations based on the state machine's outputs."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'[Meta(typeof(IAutoNode))]\npublic partial class PlayerModel : Node3D {\n  public override void _Notification(int what) => this.Notify(what);\n\n  #region Dependencies\n  [Dependency]\n  public IPlayerLogic PlayerLogic => DependOn<IPlayerLogic>();\n  #endregion Dependencies\n\n  public void OnResolved() {\n    PlayerBinding = PlayerLogic.Bind();\n\n    PlayerBinding\n      .Handle<PlayerLogic.Output.Animations.Idle>(\n        (output) => AnimationStateMachine.Travel("idle")\n      )\n      .Handle<PlayerLogic.Output.Animations.Move>(\n        (output) => AnimationStateMachine.Travel("move")\n      )\n      .Handle<PlayerLogic.Output.Animations.Jump>(\n        (output) => AnimationStateMachine.Travel("jump")\n      )\n      .Handle<PlayerLogic.Output.Animations.Fall>(\n        (output) => AnimationStateMachine.Travel("fall")\n      )\n      .Handle<PlayerLogic.Output.MoveSpeedChanged>(\n        (output) => AnimationTree.Set(\n          "parameters/main_animations/move/blend_position", output.Speed\n        )\n      );\n  }\n\n  // ...\n}\n')),(0,o.kt)("h3",{id:"\ufe0f-simplified-dependencies"},"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f Simplified Dependencies"),(0,o.kt)("p",null,"Using such a simple dependency system provides a number of advantages."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Simple to reason about."),(0,o.kt)("li",{parentName:"ul"},"Follows Godot's natural tree-based structure."),(0,o.kt)("li",{parentName:"ul"},"Avoids nullability issues. Objects only exist when needed, where needed. Either the object and its dependents exist, or none of them exist. No more checking from your dependents to see if the thing you need is null or has null values."),(0,o.kt)("li",{parentName:"ul"},"Declarative style of coding, making it clear what's responsible for what.")),(0,o.kt)("p",null,"Behind the scenes, AutoInject takes care of looking up providers, caching, subscribing to providers while it waits for them to provide values, and invalidating the cache when re-entering the tree. All we have to do is say what we're providing or what we want, and make sure our descendants are placed beneath ancestors that give them the values they need."),(0,o.kt)("p",null,"In the game demo, you can just search for ",(0,o.kt)("inlineCode",{parentName:"p"},"[Dependency]")," to see every value that's looked up from an ancestor node. The visual nodes in the demo make extensive use of AutoInject to lookup repositories. Once dependencies are resolved, the repositories are passed to the state machines for the nodes."),(0,o.kt)("h2",{id:"-testing"},"\ud83e\uddd1\u200d\ud83d\udd2c Testing"),(0,o.kt)("p",null,'If a software architecture allows all of the application\'s individual "units" \u2014 i.e., network clients, repositories, states, and views \u2014 to be tested independently of each other, it\'s probably a decent architecture. After all, testing something in isolation is the definition of a "unit test".'),(0,o.kt)("p",null,'In unit testing, a "unit" is the smallest possible unit of code that can be tested in isolation. This annoying, recursive definition is important, because the quality of the architecture can determine how big a unit is. In an ideal world, each unit would belong in one \u2014 and only one \u2014 layer of abstraction.'),(0,o.kt)(p,{src:n(9103).Z,alt:"Not-so-layered architecture",mdxType:"FancyImage"},"We've all been there."),(0,o.kt)("p",null,"Historically, unit-testing visual components in game engines has been nearly impossible. Even Unity admits that a ",(0,o.kt)("inlineCode",{parentName:"p"},"MonoBehavior")," ",(0,o.kt)("a",{parentName:"p",href:"https://blog.unity.com/technology/unit-testing-part-2-unit-testing-monobehaviours"},"can't really be unit-tested"),"."),(0,o.kt)("p",null,"In Godot, things are a little better. You can easily spin up a new instance of a scene, add it to a test scene, and use ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/GoDotTest"},"GoDotTest")," with ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/derkork/godot-test-driver"},"GodotTestDriver")," to call the scene script's methods and assert that it manipulates the engine environment as you expect, and then undo anything it changes."),(0,o.kt)("p",null,"Most people stop at this point, perfectly happy to be able to write tests for most things in their game. And that's fine, especially if you don't want to measure code coverage."),(0,o.kt)("p",null,"If you cannot quench your thirst for testing, and you find yourself wanting to measure code coverage accurately, the approach mentioned above won't quite work. You'll quickly realize that spinning up a scene means any of its child scenes get spun up, too. And if those child scenes have scripts, those get executed. That brings in a ton of other systems that you need to mock or swap in fake objects for, but there's no way to intercept the deserialization of the scene and swap everything out."),(0,o.kt)("p",null,'By now, your simple "unit" test has gone supernova, and is crossing so many layers of abstractions that your test has exploded into an integration test. As a result, your test ends up testing everything else in your game, and your code coverage becomes meaningless.'),(0,o.kt)(p,{src:n(792).Z,alt:"The scene explosion problem.",mdxType:"FancyImage"},"Testing a scene in isolation is very hard to do, since they directly deserialize child scenes and their scripts."),(0,o.kt)("p",null,"After all, code coverage is only accurate if you test each system in perfect isolation. Otherwise, you're contaminating the results and you won't be able to easily tell which systems you haven't tested yet."),(0,o.kt)("p",null,"I can hear you wondering \"well, what's the point of unit testing, then? Is it even worth it to test such small 'units' of functionality?\""),(0,o.kt)("p",null,"Yes, but not because we want to verify behavior. That's just an added bonus."),(0,o.kt)("p",null,"Wait, what? The point of unit testing isn't to verify behavior? Correct \u2014 at least, in my opinion."),(0,o.kt)("h3",{id:"-why-write-unit-tests-at-all"},"\ud83e\uddea Why Write Unit Tests At All?"),(0,o.kt)("p",null,'I feel the same about unit tests as I do about high school teachers insisting we "show our work" in algebra class. It\'s a total chore, but it builds expertise and it\'s the right thing to do, even if you can just "solve it all in your head" (you never can when it comes to code).'),(0,o.kt)("p",null,"Chores are just that. Necessary. We have to keep our houses clean or we end up with a bug infestation. Likewise, we have to keep our code clean or we end up with \u2014 wait. You get the idea."),(0,o.kt)("p",null,"If you, like me, dread cleaning your house, you should recall the age-old rule: if you have to do something you don't like, make it as easy as possible to do. Set yourself up for success. Listen to your favorite music while you clean the house and promise yourself you'll go out to dinner after."),(0,o.kt)("p",null,"So here's why I actually think unit tests are important:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},'Unit tests are "showing your work."')," They ensure every line of code is executed at least once."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Unit tests enforce consistency and ensure your architecture is followed.")," If you're not following the same architecture, it becomes harder to write tests. - Let's be honest: most tests start out as a copy/paste of some other tests, so you want to get this right up front."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Unit tests are disposable.")," If you refactor something heavily, it's probably easier to just delete the tests and start over than it is to refactor the tests. Plus, you'll end up with better tests and it's often faster, anyways. If you're writing code decently well, this will be a non-issue."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Unit tests act as living documentation.")," Your project wouldn't compile if they weren't up-to-date. If a developer needs to know how to use a particular piece of code, they can quickly look at the tests and get everything they need, because all of that code's capabilities will have tests."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Unit tests verify the state and/or behavior of the test subject."))),(0,o.kt)("p",null,"The fact that unit tests verify your code does what you say it does is just the icing on top. If code is strongly coupled, it becomes almost impossible to unit test. The mere existence of unit tests proves the code isn't terrible."),(0,o.kt)(p,{src:n(9493).Z,alt:"Why that one teammate won't shut up about unit tests",mdxType:"FancyImage"},"Now you can be that annoying teammate that won't shut up about unit tests!"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"If unit tests feel repetitive, it's because they are.")," Depending on the test subject, you might end up testing a bit of behavior and state, which means that some of the tests can end up pretty tightly coupled. Obviously, with some practice or test utility abstractions, you can make them less coupled, but there tend to be plenty of tests that are basically just verifying the implementation of the test subject. And that's fine, because they're disposable. With today's AI-assisted coding, you'll be fine \u2014 I promise."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"If you're just making a prototype of a game to get the gameplay right, you're not going to want to write many unit tests, if any. Unit testing tends to lock-in a lot of code, so don't do it until you're making the actual game.")),(0,o.kt)("p",null,"An optimal architecture allows a game to achieve 100% code coverage through unit tests. There will always be situations where performance-critical code might be so tightly coupled that testing it in isolation is too difficult and a unit crosses more than one layer of abstraction. Fortunately, if everything else in your codebase is modularized enough to be tested in isolation, carving out a little blast radius where the rules are broken is perfectly allowable. It's one of those \u201cyou have to know the rules to break the rules\u201d type of things."),(0,o.kt)("p",null,"Assuming you're convinced, let's talk about how it's actually done, now."),(0,o.kt)("h3",{id:"-unit-tests-in-practice"},"\ud83d\udd2c Unit Tests In Practice"),(0,o.kt)("p",null,"To be able to test Godot scenes that incorporate other scenes, we need to be able make an instance of a scene without deserializing the actual scene file. Fortunately, Godot allows us to just ",(0,o.kt)("inlineCode",{parentName:"p"},"new")," up any scene script we want \u2014 problem solved. Except, not quite. Once we add the script to the test scene to begin testing it, it will crash if it tries to find any children, since it won't have any. The child instances come from the ",(0,o.kt)("inlineCode",{parentName:"p"},".tscn")," file that we'd normally deserialize when loading a scene, but since we just created an instance of a script, there won't be any children."),(0,o.kt)("p",null,"That's fine. We can just add a little functionality to our script (using a mixin) that simulates a fake node tree and returns fake nodes based on the paths it expects. This works surprisingly well, except we can't return interfaces, making mocking impossible. The reason we can't return interfaces is because Godot nodes don't actually have any corresponding interfaces \u2014 they're just classes."),(0,o.kt)("p",null,"Since there\u2019s no interfaces, we have to create an actual node for every child. And that gets really tedious really fast, resulting in a ton of test fixtures."),(0,o.kt)("p",null,"So, to get around this, I\u2019ve created ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/GodotNodeInterfaces"},"GodotNodeInterfaces"),", which generates interfaces and adapters for every type of Godot node. It also provides alternative methods for accessing child nodes as their adapted interface, and works with a fake scene tree system for testing."),(0,o.kt)(p,{src:n(7).Z,alt:"Layers of Abstraction in Testing",mdxType:"FancyImage"},"Some things just can't be automated."),(0,o.kt)("p",null,"I haven't done extensive profiling with GodotNodeInterfaces, since I was getting hundreds of frames per second while using it. I imagine there\u2019s a slight performance impact in cases where the compiler can\u2019t inline everything."),(0,o.kt)("p",null,"Because the alternative child access functions GodotNodeInterfaces provides return wrapped versions of real Godot nodes, there\u2019s an allocation overhead. Fortunately, the allocation overhead can be mitigated by storing node references at the time your node script is created, getting all the allocations out of the way at once."),(0,o.kt)("p",null,"If you\u2019re still worried about performance, though, take it from one of my personal heroes, ",(0,o.kt)("a",{parentName:"p",href:"https://twitter.com/munificentbob"},"Bob"),":"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"My experience, though, is that it\u2019s easier to make a fun game fast than it is to make a fast game fun. One compromise is to keep the code flexible until the design settles down and then tear out some of the abstraction later to improve your performance. \u2014 ",(0,o.kt)("a",{parentName:"p",href:"https://gameprogrammingpatterns.com/architecture-performance-and-games.html"},"Architecture, Performance, and Games"))),(0,o.kt)("p",null,"See? There\u2019s always plenty of time to write bad code! Once your game becomes sickeningly clean, stable, and fun to play, you have my blessing to corrupt it for the sake of performance. After all, \u201call magic comes at a price,\u201d or something like that."),(0,o.kt)("h3",{id:"-testing-tips"},"\ud83d\udc81 Testing Tips"),(0,o.kt)("p",null,"If you haven't done much testing with C#, you'll probably want to familiarize yourself with the basics, ",(0,o.kt)("a",{parentName:"p",href:"https://www.codemag.com/Article/2305041/Using-Moq-A-Simple-Guide-to-Mocking-for-.NET"},"including mocking"),"."),(0,o.kt)("p",null,"In this last section, we'll demonstrate how the architecture we've outlined above allows us to test everything relatively easily."),(0,o.kt)("h4",{id:"-understanding-visual-testing"},"\ud83c\udfa8 Understanding Visual Testing"),(0,o.kt)("p",null,"To test visual components, we have to reason very carefully about them. As mentioned previously, there's two ways to instantiate a Godot node for testing."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Instantiate the visual component's scene script directly. We avoid doing this in unit tests since it would pollute code coverage by executing more than one unit in a uni-test. For integration tests when we're not measuring code coverage, instantiating scenes directly works easily enough.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Create a new instance of a scene script, without deserializing its scene. This breaks child relationships once added to a scene tree, since those children don't exist since we didn't deserialize a scene file. We can get around this by using a fake scene tree system, which is what GodotNodeInterfaces provides."))),(0,o.kt)("p",null,"We will always use approach ",(0,o.kt)("inlineCode",{parentName:"p"},"#2"),"."),(0,o.kt)("p",null,"Once we have an instance of a node to test, there's two ways to test it."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"We can add the node to the test scene tree, which allows it to manipulate the game engine environment and take up space in the world. For many nodes, we ",(0,o.kt)("strong",{parentName:"p"},"have")," to actually add them to the scene tree during testing to be able to verify their interactions with the engine.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Alternatively, we can just call methods on the node without adding them to the scene tree. This works if nothing in the methods manipulates the scene tree or other properties of the node that require it to be in the tree. For many nodes, we can get away with this approach, since it's a bit simpler."))),(0,o.kt)("h4",{id:"-setting-up-testing"},"\ud83d\udc77 Setting Up Testing"),(0,o.kt)("p",null,"We'll be using ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/GoDotTest"},"GoDotTest")," as our test runner. GoDotTest guarantees a few invariants for us that help us run tests deterministically."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Tests are always executed one at a time, in the order they appear in the code for a particular test class."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Setup")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"Cleanup")," methods can be called before and after each test, and ",(0,o.kt)("inlineCode",{parentName:"li"},"SetupAll")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"CleanupAll")," methods can be called before and after running a test suite (i.e., a test class)."),(0,o.kt)("li",{parentName:"ul"},"Tests are able to be placed on the test scene."),(0,o.kt)("li",{parentName:"ul"},"Tests can be run from the command-line, for CI/CD purposes."),(0,o.kt)("li",{parentName:"ul"},"Tests are never run in parallel."),(0,o.kt)("li",{parentName:"ul"},"Tests and their setup methods can be asynchronous, or not.")),(0,o.kt)("h4",{id:"-two-phase-initialization"},"\ud83e\uddec Two-Phase Initialization"),(0,o.kt)("p",null,"We frequently need to ",(0,o.kt)("strong",{parentName:"p"},"separate our script's initialization into two phases"),": one phase for ",(0,o.kt)("strong",{parentName:"p"},"creating the values")," that belong to that script, such as its dependencies, state machines, and bindings, and the second for ",(0,o.kt)("strong",{parentName:"p"},"using those dependencies or bindings"),". If we don't separate the initialization from the usage, we won't have a way to inject mock values during a unit test since the values would be created and immediately used afterwards."),(0,o.kt)("p",null,"In practice, here's what splitting our initialization into two-phases looks like."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"[Meta(typeof(IAutoNode))]\npublic partial class InGameUI : Control, IInGameUI {\n  public override void _Notification(int what) => this.Notify(what);\n\n  #region Dependencies\n  [Dependency]\n  public IAppRepo AppRepo => DependOn<IAppRepo>();\n  #endregion Dependencies\n\n  #region Nodes\n  [Node]\n  public ILabel CoinsLabel { get; set; } = default!;\n  #endregion Nodes\n\n  #region State\n  public IInGameUILogic InGameUILogic { get; set; } = default!;\n  public InGameUILogic.IBinding InGameUIBinding { get; set; } = default!;\n  #endregion State\n\n  public void Setup() {\n    InGameUILogic = new InGameUILogic(this, AppRepo);\n  }\n\n  public void OnResolved() {\n    InGameUIBinding = InGameUILogic.Bind();\n\n    InGameUIBinding\n      .Handle<InGameUILogic.Output.NumCoinsCollectedChanged>(\n        (output) => SetCoinsLabel(\n          output.NumCoinsCollected, AppRepo.NumCoinsAtStart.Value\n        )\n      )\n      .Handle<InGameUILogic.Output.NumCoinsAtStartChanged>(\n        (output) => SetCoinsLabel(\n          AppRepo.NumCoinsCollected.Value, output.NumCoinsAtStart\n        )\n      );\n\n    InGameUILogic.Start();\n  }\n")),(0,o.kt)("p",null,"Once again, we're looking at the ",(0,o.kt)("inlineCode",{parentName:"p"},"InGameUI")," view that displays the number of coins the user has collected while in-game. Notice the separate methods, ",(0,o.kt)("inlineCode",{parentName:"p"},"Setup()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"OnResolved()"),". The first method creates the ",(0,o.kt)("inlineCode",{parentName:"p"},"InGameUILogic")," state machine, while the second binds to the state machine's outputs and starts the state machine."),(0,o.kt)("p",null,"Since the script above uses ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/AutoInject"},"AutoInject")," to resolve dependencies, we can leverage a lesser-known feature of AutoInject to help with this initialization process. AutoInject normally calls the ",(0,o.kt)("inlineCode",{parentName:"p"},"OnResolved()")," method on your script once all the providers it found for your script's dependencies indicate they've provided their values, but there's more to it than that."),(0,o.kt)("p",null,"If you have a ",(0,o.kt)("inlineCode",{parentName:"p"},"Setup()")," method on your script, that method will be called after dependencies are resolved, but right before ",(0,o.kt)("inlineCode",{parentName:"p"},"OnResolved()")," is called \u2014 if, and only if \u2014 your script's ",(0,o.kt)("inlineCode",{parentName:"p"},"IsTesting")," property is set to false. The ",(0,o.kt)("inlineCode",{parentName:"p"},"IsTesting")," property isn't shown, though \u2014 it's tucked away in a generated file."),(0,o.kt)("p",null,"By utilizing two-phase initialization, we are able to test our game component easily within the scene tree."),(0,o.kt)("p",null,"I won't show full tests here, but you can check out the tests for the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/GameDemo/blob/main/test/src/player/PlayerTest.cs"},"Player")," node. It takes advantage of the two-phase initialization by preventing the Player's ",(0,o.kt)("inlineCode",{parentName:"p"},"Setup()")," method from ever being invoked when running in the actual test scene, ensuring our mocked values get injected instead."),(0,o.kt)("h4",{id:"-faking-the-scene-tree"},"\ud83c\udf32 Faking the Scene Tree"),(0,o.kt)("p",null,"Each scene should have only one script on its root node."),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"If you find yourself needing to add a script to a non-root node in a Godot scene, don\u2019t. Instead, save the node branch as its own scene before adding a script to it."),(0,o.kt)("p",{parentName:"admonition"},'Likewise, if you you find yourself writing a Godot node script that manipulates its grandchildren, you may run into difficulty testing the script as a unit-test with a fake node tree. For best results, add a script to the child and ask it to manipulate its own children from your script. The general rule of thumb is "no script should manipulate nodes deeper than its children."')),(0,o.kt)("p",null,"Ensuring each scene only has one script on its root node allows you to make use of the fake scene tree system provided by ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/GodotNodeInterfaces"},"GodotNodeInterfaces")," to easily test your scene. By referencing nodes as interfaces and automatically hooking them up with the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/AutoInject"},(0,o.kt)("inlineCode",{parentName:"a"},"IAutoConnect"))," mixin, we can easily test our scene in isolation without spinning up the entire subtree."),(0,o.kt)("p",null,"In the example below, taken from the game demo's ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/GameDemo/blob/main/test/src/coin/CoinTest.cs#L47-L50"},"unit tests for the spinning gold coins"),", we setup our tests by creating mock versions of the values the coin needs and then call the ",(0,o.kt)("inlineCode",{parentName:"p"},"FakeNodeTree")," to instruct our coin to use the mock objects for nodes at the provided paths instead of trying to connect to real children nodes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'  [Setup]\n  public void Setup() {\n    _appRepo = new Mock<IAppRepo>();\n    _animPlayer = new Mock<IAnimationPlayer>();\n    _coinModel = new Mock<INode3D>();\n    _logic = new Mock<ICoinLogic>();\n    _binding = CoinLogic.CreateFakeBinding();\n\n    _logic.Setup(logic => logic.Bind()).Returns(_binding);\n\n    _coin = new Coin {\n      IsTesting = true,\n      AnimationPlayer = _animPlayer.Object,\n      CoinModel = _coinModel.Object,\n      CoinLogic = _logic.Object,\n      CoinBinding = _binding\n    };\n\n    _coin.FakeDependency(_appRepo.Object);\n\n    _coin.FakeNodeTree(new() {\n      ["%AnimationPlayer"] = _animPlayer.Object,\n      ["%CoinModel"] = _coinModel.Object\n    });\n  }\n')),(0,o.kt)("h4",{id:"-mocking-dependencies-provided-with-autoinject"},"\ud83e\udd78 Mocking Dependencies Provided with AutoInject"),(0,o.kt)("p",null,"In the example above, we also used the ",(0,o.kt)("inlineCode",{parentName:"p"},"FakeDependency")," method generated with AutoInject. Faking a dependency prevents the dependent node from searching the tree for providers \u2014\xa0which wouldn't be present in a test scenario where you're just testing a script by itself. Instead, the dependent node we're testing will just use the provided value when it looks up a dependency of that type, allowing us to easily mock dependencies."),(0,o.kt)("h2",{id:"-file-structure-and-feature-based-architecture"},"\ud83d\uddc2 File Structure and Feature-Based Architecture"),(0,o.kt)("p",null,"Files should be organized in a way that benefits the artists and developers contributing to the codebase. Allow me to suggest feature-based organization here."),(0,o.kt)("p",null,"In feature-based organization, files are organized by feature, with any files that get shared between features in some sort of shared directory, typically called something like ",(0,o.kt)("inlineCode",{parentName:"p"},"common"),"."),(0,o.kt)("p",null,'In the game demo, we define features pretty simply. The player runs around collecting coins, jumping on mushrooms, and interacting with a physical environment. So, a mushroom is a feature, so is a coin, etc. You can define features however you want, but you probably want to check out the section "Thinking in Tokens" in Chapter 17 (page 482) of ',(0,o.kt)("em",{parentName:"p"},"Game Architecture and Design: A New Edition")," by Rollings and Morris."),(0,o.kt)("p",null,"In feature-based architecture, you really want to avoid strongly coupling your features together. If you can keep them loosely coupled, you can add and remove them with ease."),(0,o.kt)("p",null,"Take a look at how the files are implemented for the Coin feature:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"\u251c\u2500\u2500 src\n\u2502\xa0\xa0 \u251c\u2500\u2500 coin\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 Coin.cs\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 Coin.tscn\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 CollectorDetector.tscn\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 audio\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 coin_collected.mp3\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 coin_collected.mp3.import\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 state\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 CoinLogic.Input.cs\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 CoinLogic.Output.cs\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 CoinLogic.State.cs\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 CoinLogic.cs\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 CoinLogic.g.puml\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 states\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0     \u251c\u2500\u2500 CoinLogic.State.Collecting.cs\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0     \u2514\u2500\u2500 CoinLogic.State.Idle.cs\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 visuals\n\u2502\xa0\xa0 \u2502\xa0\xa0     \u251c\u2500\u2500 coin_model.glb\n\u2502\xa0\xa0 \u2502\xa0\xa0     \u251c\u2500\u2500 coin_model.glb.import\n\u2502\xa0\xa0 \u2502\xa0\xa0     \u251c\u2500\u2500 coin_normal.tres\n\u2502\xa0\xa0 \u2502\xa0\xa0     \u251c\u2500\u2500 coin_roughness.tres\n\u2502\xa0\xa0 \u2502\xa0\xa0     \u251c\u2500\u2500 coin_texture.tres\n\u2502\xa0\xa0 \u2502\xa0\xa0     \u2514\u2500\u2500 teleport_3d.gdshader\n")),(0,o.kt)("p",null,"Everything the coin needs is located inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"coin")," folder. Even the states for the state machine are located in the ",(0,o.kt)("inlineCode",{parentName:"p"},"state/states")," subfolder. All the other features are organized in the same way, too, making it easy for a developer to jump in and fix something, even if she hasn't been working on that feature. Artists can also quickly intuit where they might need to drop some updated visuals, too."),(0,o.kt)("p",null,"I often see people suggest to keep separate folders for each type of file, like ",(0,o.kt)("inlineCode",{parentName:"p"},"scripts"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"scenes"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"textures"),", etc. My little brain finds this organizational pattern difficult since related files are split across multiple places and it makes it harder to remember to go and rename the corresponding files in top-level directories elsewhere whenever you decide to rename something. You also have to know how to identify all the related files, too, which becomes a memory exercise in and of itself."),(0,o.kt)("h3",{id:"-preventing-strong-coupling-in-features"},"\ud83e\udea2 Preventing Strong Coupling in Features"),(0,o.kt)("p",null,"To keep my features from being strongly coupled to each other, I made them interact with each other via interfaces. For example, the coin can be collected by anything that implements ",(0,o.kt)("inlineCode",{parentName:"p"},"ICoinCollector"),". The coin doesn't care what it is, it just knows that it can be collected by anything that implements that interface. In the game, it's just the player."),(0,o.kt)("p",null,"To facilitate this, I simply created a folder in my ",(0,o.kt)("inlineCode",{parentName:"p"},"src")," directory that contained interfaces used across features. I could have put these in a common directory, but I decided to have a ",(0,o.kt)("inlineCode",{parentName:"p"},"traits")," directory for this sort of thing."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"\u251c\u2500\u2500 src\n\u2502\xa0\xa0 \u251c\u2500\u2500 traits\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 ICoinCollector.cs\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 IKillable.cs\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 IPushEnabled.cs\n")),(0,o.kt)("p",null,"No doubt, you can find further organizational patterns that improve on this. When you do, please pop into our Discord and share them with me ^-^."),(0,o.kt)("h3",{id:"-file-structure-for-tests"},"\ud83c\udfdb File Structure for Tests"),(0,o.kt)("p",null,"The unit tests for everything in the game demo are 1:1 mirror of everything in the source directory that needs tests, with the added ",(0,o.kt)("inlineCode",{parentName:"p"},"Test")," suffix added to each file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"\u2514\u2500\u2500 test\n    \u2514\u2500\u2500 src\n        \u251c\u2500\u2500 coin\n        \u2502\xa0\xa0 \u251c\u2500\u2500 CoinTest.cs\n        \u2502\xa0\xa0 \u2514\u2500\u2500 state\n        \u2502\xa0\xa0     \u251c\u2500\u2500 CoinLogicTest.cs\n        \u2502\xa0\xa0     \u2514\u2500\u2500 states\n        \u2502\xa0\xa0         \u251c\u2500\u2500 CoinLogic.State.CollectingTest.cs\n        \u2502\xa0\xa0         \u2514\u2500\u2500 CoinLogic.State.IdleTest.cs\n")),(0,o.kt)("h2",{id:"-conclusion"},"\ud83e\udd70 Conclusion"),(0,o.kt)("p",null,"Thank you for reading my (excessively long) article on game architecture. There's no way I could dive into everything into as much detail as I wanted, so if you have questions, please feel free to reach out to me. If you find ways of working that are easier, better, and more enjoyable, please don't keep them to yourself. I'd love to assimilate your knowledge!"),(0,o.kt)(d,{mdxType:"Spacer"},(0,o.kt)(g,{mdxType:"BlogDiscordInvite"})))}f.isMDXComponent=!0},5432:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/header-ea6f7d4f5f558f0c32f8a911c6e971bc.jpg"},826:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/architecture_sanity-b15bf35a04b9a6bcad219cad75611dc8.png"},393:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/chess-183449097e1234bf9763685956c76252.png"},653:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/game_architecture-867fa678f6d73270240dfe3c2729d661.png"},8370:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/game_engine-974d2810a76193ccddf93020fdc2bdd5.png"},9103:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/not_so_layered_architecture-4368ee6fffc9045d2141c5c9f820e6b9.png"},6975:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/player-07a393d7baeac69a0a584374cbb3cf32.png"},792:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/scene_explosion-021278970cf535231554b8004238174a.png"},4105:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/separating_game_logic-d773fc638f7b0437dc5277667fcd1a41.png"},7:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/testing_abstractions-888f71e1739a5903bc8f5bb81a0f2b08.png"},5104:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tree_based_dependencies-7250bda99e3525c675bcd4e26f9331af.png"},9493:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/unit_tests-31d71e2c67517d684e0821fe3260f8df.png"},4602:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/visual_component-455386920e6cd1664d664d4e801c1cc9.png"},3806:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/visual_game_logic-58ace245755dd76920efc883b3017c33.png"},938:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/white_whale-5a772e414e51ef8cad4267dbb811e8d0.png"},5790:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/header-ea6f7d4f5f558f0c32f8a911c6e971bc.jpg"}}]);