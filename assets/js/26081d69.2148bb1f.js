"use strict";(self.webpackChunkchickensoft_site=self.webpackChunkchickensoft_site||[]).push([[7819],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(n),m=o,g=d["".concat(l,".").concat(m)]||d[m]||p[m]||r;return n?a.createElement(g,i(i({ref:t},c),{},{components:n})):a.createElement(g,i({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5038:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(7462),o=(n(7294),n(3905));const r={title:"\ud83d\udce4 Outputs",slug:"outputs",image:"../header.jpg"},i=void 0,s={unversionedId:"logic_blocks/basics/outputs",id:"logic_blocks/basics/outputs",title:"\ud83d\udce4 Outputs",description:"Outputs are temporary, disposable objects that are produced by a state and immediately passed to each of the logic block's listeners and bindings.",source:"@site/docs/logic_blocks/04_basics/03_outputs.md",sourceDirName:"logic_blocks/04_basics",slug:"/logic_blocks/basics/outputs",permalink:"/docs/logic_blocks/basics/outputs",draft:!1,editUrl:"https://github.com/chickensoft-games/chickensoft_site/tree/main/docs/logic_blocks/04_basics/03_outputs.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"\ud83d\udce4 Outputs",slug:"outputs",image:"../header.jpg"},sidebar:"tutorialSidebar",previous:{title:"\ud83d\udd04 States",permalink:"/docs/logic_blocks/basics/states"},next:{title:"\u274c Errors",permalink:"/docs/logic_blocks/basics/errors"}},l={},u=[{value:"\ud83d\ude92 Responding to Outputs",id:"-responding-to-outputs",level:3},{value:"\ud83e\udd4a Outputs vs Direct Manipulation",id:"-outputs-vs-direct-manipulation",level:2}],c={toc:u};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Outputs")," are temporary, disposable objects that are produced by a state and immediately passed to each of the logic block's listeners and bindings."),(0,o.kt)("p",null,"An output is a state's way of indicating something of interest has happened without having to be tightly coupled to interested systems."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"partial class DimmableLightSwitch {\n    public static class Output {\n        public readonly record struct StatusChanged(bool IsOn);\n    }\n}\n")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"By convention, outputs are shown stored in a simple static class called ",(0,o.kt)("inlineCode",{parentName:"p"},"Output")," inside the logic block that owns them.")),(0,o.kt)("p",null,"Outputs are produced from inside a state by calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"Output")," method."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public record PoweredOn : State {\n  public PoweredOn() {\n    this.OnEnter(() =>\n      // Produce an output when we enter this state.\n      Output(new Output.StatusChanged(IsOn: true))\n    );\n  }\n}\n")),(0,o.kt)("p",null,"Like inputs, outputs should be ",(0,o.kt)("inlineCode",{parentName:"p"},"readonly record struct")," types."),(0,o.kt)("h3",{id:"-responding-to-outputs"},"\ud83d\ude92 Responding to Outputs"),(0,o.kt)("p",null,"Whenever an output is produced, any bindings or logic block listeners will be invoked immediately. If you're using structs, this will keep outputs from ever hitting the heap \u2014\xa0ensuring zero memory allocations occur."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'using var binding = lightSwitch.Bind();\n\n// Monitor an output:\nbinding.Handle((in LightSwitch.Output.StatusChanged output) =>\n  System.Console.WriteLine(\n    $"Status changed to {(output.IsOn ? "on" : "off")}"\n  )\n);\n')),(0,o.kt)("h2",{id:"-outputs-vs-direct-manipulation"},"\ud83e\udd4a Outputs vs Direct Manipulation"),(0,o.kt)("p",null,"LogicBlocks provides two different mechanisms that states can use to mutate objects outside the state:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"call methods directly on blackboard objects"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public Transition On(in Input.SomethingHappened input) {\n  Get<MyRelatedService>().ChangeSomething(input.Value);\n\n  return ToSelf();\n}\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"produce outputs for objects that bind to the logic block"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public Transition On(in Input.SomethingHappened input) {\n  Output(new Output.ChangeSomething(input.Value));\n\n  return ToSelf();\n}\n")))),(0,o.kt)("p",null,"You can use either mechanism depending on the situation."),(0,o.kt)("p",null,"If you're following the ",(0,o.kt)("a",{parentName:"p",href:"/blog/game-architecture"},"enjoyable game architecture")," guide, prefer calling methods to mutate services in the layer below the logic block (the non-visual game logic layer), and produce outputs to influence the view layer above you (game entity scripts, etc)."),(0,o.kt)("p",null,"If you wish, you can restrict what operations are possible from a logic block by getting and setting blackboard objects by the type of the interface you wish to interact with them as."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"logic = new MyLogicBlock();\n\nlogic.Set(new MyRelatedService() as IMyRelatedService)\n//  or, same as above:\nlogic.Set<IMyRelatedService>(new MyRelatedService())\n\n// elsewhere, in your logic block state\n  public Transition On(in Input.SomethingHappened input) {\n    // must access by the type it was stored as\n    var something = Get<IMyRelatedService>().GrabSomethingForMe();\n\n    // ...\n\n    return ToSelf();\n  }\n")))}p.isMDXComponent=!0}}]);