"use strict";(self.webpackChunkchickensoft_site=self.webpackChunkchickensoft_site||[]).push([[1766],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=s(n),h=a,m=d["".concat(p,".").concat(h)]||d[h]||c[h]||o;return n?r.createElement(m,i(i({ref:t},u),{},{components:n})):r.createElement(m,i({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8311:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=n(7462),a=(n(7294),n(3905));const o={title:"\ud83d\udd06 Power",image:"../header.jpg"},i=void 0,l={unversionedId:"logic_blocks/tutorial/power",id:"logic_blocks/tutorial/power",title:"\ud83d\udd06 Power",description:"We know we'll need a PoweredOn state, too. Whenever the user presses the power button, we should toggle between off and on.",source:"@site/docs/logic_blocks/05_tutorial/02_power.md",sourceDirName:"logic_blocks/05_tutorial",slug:"/logic_blocks/tutorial/power",permalink:"/docs/logic_blocks/tutorial/power",draft:!1,editUrl:"https://github.com/chickensoft-games/chickensoft_site/tree/main/docs/logic_blocks/05_tutorial/02_power.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"\ud83d\udd06 Power",image:"../header.jpg"},sidebar:"tutorialSidebar",previous:{title:"\ud83e\uddca Timer Logic Block",permalink:"/docs/logic_blocks/tutorial/timer_logic_block"},next:{title:"\u23f3 Countdown",permalink:"/docs/logic_blocks/tutorial/coundown"}},p={},s=[{value:"\u23f0 Changing the Timer&#39;s Duration",id:"-changing-the-timers-duration",level:2}],u={toc:s};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"We know we'll need a ",(0,a.kt)("inlineCode",{parentName:"p"},"PoweredOn")," state, too. Whenever the user presses the power button, we should toggle between off and on."),(0,a.kt)("p",null,"Fortunately, that's easy to do. We just create another state and an input for the power button being toggled."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"[Meta, LogicBlock(typeof(State), Diagram = true)]\npublic partial class Timer : LogicBlock<Timer.State> {\n  public override Transition GetInitialState() => To<State.PoweredOff>();\n\n  public static class Input {\n    public readonly record struct PowerButtonPressed;\n  }\n\n  public static class Output;\n\n  public abstract record State : StateLogic<State> {\n\n    public record PoweredOff : State, IGet<Input.PowerButtonPressed> {\n      public Transition On(in Input.PowerButtonPressed input) =>\n        To<PoweredOn.Idle>();\n    }\n\n    public abstract record PoweredOn : State, IGet<Input.PowerButtonPressed> {\n      public Transition On(in Input.PowerButtonPressed input) =>\n        To<PoweredOff>();\n\n      public record Idle : PoweredOn;\n    }\n  }\n}\n")),(0,a.kt)("p",null,"Whenever a state wants to handle a type of input, it simply implements the ",(0,a.kt)("inlineCode",{parentName:"p"},"IGet<TInput>")," interface with the type of the input we're interested in. Then, you simply implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"On(in TInput input)")," method and return the transition to the next state."),(0,a.kt)("p",null,"Transitions are defined with the ",(0,a.kt)("inlineCode",{parentName:"p"},"To<TState>()")," method. If you don't want to transition to another state in an input handler, you can always return ",(0,a.kt)("inlineCode",{parentName:"p"},"ToSelf()"),"."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"PoweredOff")," state now handles the ",(0,a.kt)("inlineCode",{parentName:"p"},"PowerButtonPressed")," input and will go to the new ",(0,a.kt)("inlineCode",{parentName:"p"},"Idle")," state, which inherits from ",(0,a.kt)("inlineCode",{parentName:"p"},"PoweredOn"),"."),(0,a.kt)("p",null,"Likewise, the ",(0,a.kt)("inlineCode",{parentName:"p"},"PoweredOn")," state also handles the same ",(0,a.kt)("inlineCode",{parentName:"p"},"PowerButtonPressed")," input and will go to the ",(0,a.kt)("inlineCode",{parentName:"p"},"PoweredOff")," state."),(0,a.kt)("h2",{id:"-changing-the-timers-duration"},"\u23f0 Changing the Timer's Duration"),(0,a.kt)("p",null,"We know we want the user to specify how long the timer should run. That raises another question: where do we store the value?"),(0,a.kt)("p",null,"Well, we could always add a property to one of our states. But since LogicBlocks constructs states for us (something we'll appreciate more when we talk about ",(0,a.kt)("a",{parentName:"p",href:"../serialization"},"serializing")," them), we don't really have a clean way of passing that data around."),(0,a.kt)("p",null,"Instead, let's use the shared \u2728 blackboard \u2728. We'll create a new type that contains the values we'll need to share between states and put that on the blackboard. Since this data bucket is specific to our logic block, we'll go ahead and make it a nested type of the logic block, too."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"[Meta, LogicBlock(typeof(State), Diagram = true)]\npublic partial class Timer : LogicBlock<Timer.State> {\n  public override Transition GetInitialState() => To<State.PoweredOff>();\n\n  public sealed record Data {\n    public double Duration { get; set; }\n    public double TimeRemaining { get; set; }\n  }\n\n  public Timer() {\n    // Set shared data for all states in the blackboard.\n    Set(new Data() { Duration = 30.0d });\n  }\n\n  ...\n")),(0,a.kt)("p",null,"Now, whenever we create a new timer logic block, it'll add a new instance of the timer ",(0,a.kt)("inlineCode",{parentName:"p"},"Data")," to the blackboard. Now all of our states can access the same data!"),(0,a.kt)("p",null,"Let's modify our ",(0,a.kt)("inlineCode",{parentName:"p"},"Idle")," state to receive a new input, ",(0,a.kt)("inlineCode",{parentName:"p"},"ChangeDuration"),". We'll add a property to ",(0,a.kt)("inlineCode",{parentName:"p"},"ChangeDuration")," that specifies the new duration."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public static class Input {\n  public readonly record struct PowerButtonPressed;\n  public readonly record struct ChangeDuration(double Duration);\n}\n\npublic record Idle : PoweredOn, IGet<Input.ChangeDuration> {\n  public Transition On(in Input.ChangeDuration input) {\n    Get<Data>().Duration = input.Duration;\n    return ToSelf();\n  }\n}\n")),(0,a.kt)("p",null,"All we do in the ",(0,a.kt)("inlineCode",{parentName:"p"},"ChangeDuration")," input handler is update the ",(0,a.kt)("inlineCode",{parentName:"p"},"Duration")," property on the shared ",(0,a.kt)("inlineCode",{parentName:"p"},"Data")," object and remain in the same state. Simple!"),(0,a.kt)("p",null,"While we're at it, let's go ahead and add a new input, ",(0,a.kt)("inlineCode",{parentName:"p"},"StartStopButtonPressed")," and make the ",(0,a.kt)("inlineCode",{parentName:"p"},"Idle")," state transition to a new ",(0,a.kt)("inlineCode",{parentName:"p"},"Countdown")," state when the user presses the start/stop button."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public static class Input {\n  public readonly record struct PowerButtonPressed;\n  public readonly record struct ChangeDuration(double Duration);\n  public readonly record struct StartStopButtonPressed;\n}\n\npublic record Idle : PoweredOn, IGet<Input.StartStopButtonPressed>, IGet<Input.ChangeDuration> {\n  public Transition On(in Input.ChangeDuration input) {\n    Get<Data>().Duration = input.Duration;\n    return ToSelf();\n  }\n\n  public Transition On(in Input.StartStopButtonPressed input) =>\n    To<Countdown>();\n}\n")),(0,a.kt)("p",null,"In the next part, we'll implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"Countdown")," state for our timer."))}c.isMDXComponent=!0}}]);