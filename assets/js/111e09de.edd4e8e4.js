"use strict";(self.webpackChunkchickensoft_site=self.webpackChunkchickensoft_site||[]).push([[5664],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=l(n),u=i,m=h["".concat(c,".").concat(u)]||h[u]||d[u]||o;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9402:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7462),i=(n(7294),n(3905));const o={title:"\ud83d\udd04 States",slug:"states",image:"../header.jpg"},r=void 0,s={unversionedId:"logic_blocks/basics/states",id:"logic_blocks/basics/states",title:"\ud83d\udd04 States",description:"State refers to the value maintained by a logic block.",source:"@site/docs/logic_blocks/04_basics/02_states.md",sourceDirName:"logic_blocks/04_basics",slug:"/logic_blocks/basics/states",permalink:"/docs/logic_blocks/basics/states",draft:!1,editUrl:"https://github.com/chickensoft-games/chickensoft_site/tree/main/docs/logic_blocks/04_basics/02_states.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"\ud83d\udd04 States",slug:"states",image:"../header.jpg"},sidebar:"tutorialSidebar",previous:{title:"\ud83d\udce5 Inputs",permalink:"/docs/logic_blocks/basics/inputs"},next:{title:"\ud83d\udce4 Outputs",permalink:"/docs/logic_blocks/basics/outputs"}},c={},l=[{value:"\ud83d\udce5 Handling Inputs &amp; State Changes",id:"-handling-inputs--state-changes",level:3},{value:"\ud83e\uddd1\u200d\ud83c\udfeb Blackboard",id:"-blackboard",level:3},{value:"\ud83c\udf31 Lifecycle Callbacks",id:"-lifecycle-callbacks",level:3},{value:"\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d\udc68 Attachment",id:"\ufe0f-attachment",level:4},{value:"\ud83d\udeaa Entrance and Exits",id:"-entrance-and-exits",level:4},{value:"\ud83c\udfce\ufe0f Stopping and Starting",id:"\ufe0f-stopping-and-starting",level:3},{value:"\u281b Compound / Composite States",id:"-compound--composite-states",level:3},{value:"\ud83e\udd4a Attach and Detach vs Entrance and Exit",id:"-attach-and-detach-vs-entrance-and-exit",level:3}],p=(d="FancyImage",function(e){return console.warn("Component "+d+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)});var d;const h={toc:l};function u(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"State")," refers to the value maintained by a logic block."),(0,i.kt)("p",null,"States can receive inputs, read values from the shared blackboard, and produce outputs and errors. Logic blocks don't actually do very much by themselves \u2014 the current state determines what inputs get handled."),(0,i.kt)("p",null,"States are always ",(0,i.kt)("inlineCode",{parentName:"p"},"record class")," reference types that are derived from ",(0,i.kt)("inlineCode",{parentName:"p"},"StateLogic<TState>"),", a type provided by LogicBlocks."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"using Chickensoft.Introspection;\n\n[Meta, LogicBlock(typeof(State), Diagram = true)]\npublic partial class LightSwitch : LogicBlock<LightSwitch.State> {\n\n  // Define the state. By convention, this is placed inside the logic block.\n  public abstract record State : StateLogic<State> {\n    // On state.\n    public record PoweredOn : State, IGet<Input.Toggle> {}\n\n    // Off state.\n    public record PoweredOff : State, IGet<Input.Toggle> {\n      public Transition On(in Input.Toggle input) => To<PoweredOn>();\n    }\n  }\n\n  // Define your initial state here.\n  public override Transition GetInitialState() => To<State.PoweredOff>();\n}\n")),(0,i.kt)("p",null,"Each state type can extend other state types using traditional C# inheritance, representing the idea of ",(0,i.kt)("a",{parentName:"p",href:"https://statecharts.dev/glossary/compound-state.html"},"compound states")," from statechart theory."),(0,i.kt)("p",null,"Only one instance of a state is ever active at once. When a state instance is active, we say it is ",(0,i.kt)("inlineCode",{parentName:"p"},"attached"),". When a state change occurs, the previous state instance is ",(0,i.kt)("inlineCode",{parentName:"p"},"detached"),"."),(0,i.kt)("h3",{id:"-handling-inputs--state-changes"},"\ud83d\udce5 Handling Inputs & State Changes"),(0,i.kt)("p",null,"States define input handlers which allow them to receive inputs and return the next state th e\nStates indicate which inputs they handle by implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"IGet<TInputType>")," for each type of input they want to handle."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public record MyState : State, IGet<Input.A>, IGet<Input.B>, IGet<Input.C> {\n  // Don't change states on A\n  public Transition On(in Input.A input) => ToSelf();\n\n  // Go to StateC on C\n  public Transition On(in Input.C input) => To<StateC>();\n}\n")),(0,i.kt)("p",null,"Input handlers are processed synchronously and always return a transition to the next state. We use ",(0,i.kt)("inlineCode",{parentName:"p"},"To<TState>()")," method to define a transition to another state. If you don't want to change states, simply return ",(0,i.kt)("inlineCode",{parentName:"p"},"ToSelf()"),"."),(0,i.kt)("p",null,"States are stored on the blackboard."),(0,i.kt)("h3",{id:"-blackboard"},"\ud83e\uddd1\u200d\ud83c\udfeb Blackboard"),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://github.com/chickensoft-games/Collections?tab=readme-ov-file#blackboard"},"blackboard"))," is a type of dictionary collection that allows the logic block and its states to access shared data. States look up values stored in the blackboard by their system type."),(0,i.kt)("p",null,"The logic block keeps a blackboard internally, but doesn't expose it. Instead, it implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"IBlackboard")," interface, allowing you to treat it as if it were the blackboard."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var logic = new MyLogicBlock();\n\n// Add all the dependencies that states will need.\nlogic.Set<IService>(new MyRelatedService());\n\nvar service = logic.Get<IService>();\n")),(0,i.kt)("p",null,"Each state instance has an internal context that allows it to interact with the logic block while it is attached. The base ",(0,i.kt)("inlineCode",{parentName:"p"},"StateLogic<TState>")," class that every state derives from provides a ",(0,i.kt)("inlineCode",{parentName:"p"},"Get<T>()")," method that allow the state to read values from the logic block's blackboard."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"[Meta, LogicBlock(typeof(State), Diagram = true)]\npublic partial class LightSwitch : LogicBlock<LightSwitch.State> {\n\n  public abstract record State : StateLogic<State> {\n\n    public record PoweredOn : State, IGet<Input.Toggle> {\n      public PoweredOn() {\n        OnAttach(() => {\n          Get<MyRelatedService>().StartDoingSomething()\n        });\n      }\n    }\n\n  ...\n")),(0,i.kt)("h3",{id:"-lifecycle-callbacks"},"\ud83c\udf31 Lifecycle Callbacks"),(0,i.kt)("h4",{id:"\ufe0f-attachment"},"\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d\udc68 Attachment"),(0,i.kt)("p",null,"When a state change occurs, the current state instance is ",(0,i.kt)("inlineCode",{parentName:"p"},"detached")," and the next state instance is ",(0,i.kt)("inlineCode",{parentName:"p"},"attached"),". Only one state instance is ever ",(0,i.kt)("inlineCode",{parentName:"p"},"attached")," at once."),(0,i.kt)("p",null,"States can register callbacks that allow them to know when they become attached and detached."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'public MyState() {\n  OnAttach(() => System.Console.WriteLine("MyState attached."))\n  OnDetach(() => System.Console.WriteLine("MyState detached."))\n}\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"For the sake of sanity, registering lifecycle callbacks should only be done in the state's constructor.")),(0,i.kt)("h4",{id:"-entrance-and-exits"},"\ud83d\udeaa Entrance and Exits"),(0,i.kt)("p",null,"States can also observe when they are ",(0,i.kt)("inlineCode",{parentName:"p"},"entered")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"exited"),"."),(0,i.kt)("p",null,"Unlike attachment, which is called every time a state instance is swapped for the active state of the logic block, entrance and exit callbacks are only invoked when the state's type hierarchy changes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'public MyState() {\n  this.OnEnter(() => System.Console.WriteLine("MyState entered."))\n  this.OnExit(() => System.Console.WriteLine("MyState exited."))\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"LogicBlocks guarantees correct behavior for entrance and exit callbacks with compound states")," (states that inherit other states)."),(0,i.kt)("p",null,"If you transition between two states that extend a common parent state, the common parent state will not have any of its exit callbacks invoked, since you are still in that ",(0,i.kt)("em",{parentName:"p"},"type")," of state."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Unlike ",(0,i.kt)("inlineCode",{parentName:"p"},"OnAttach")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"OnDetach"),", you have to invoke ",(0,i.kt)("inlineCode",{parentName:"p"},"OnEnter")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"OnExit")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"this.OnEnter")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"this.OnExit"),", respectively. LogicBlocks has to implement ",(0,i.kt)("inlineCode",{parentName:"p"},"this.OnEnter")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"this.OnExit")," as extension methods to properly capture the generic context. Unlike in previous versions, you don't have to specify which type of state you are entering \u2014 it just knows.")),(0,i.kt)("h3",{id:"\ufe0f-stopping-and-starting"},"\ud83c\udfce\ufe0f Stopping and Starting"),(0,i.kt)("p",null,"By default, a logic block will not create the first state until it is read, explicitly started, or receives an input. Lazily initializing state allows you to determine when the initial state should actually be attached and entered, guaranteeing that any ",(0,i.kt)("em",{parentName:"p"},"side effects")," don't occur until you're ready."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var logic = new MyLogicBlock();\n\n// Make sure the initial state is attached and entered.\nlogic.Start();\n\n// Exit and detach the current state.\nlogic.Stop();\n")),(0,i.kt)("p",null,"Starting and stopping a logic block triggers the relevant attach/detach and entrance/exit callbacks."),(0,i.kt)("h3",{id:"-compound--composite-states"},"\u281b Compound / Composite States"),(0,i.kt)("p",null,"LogicBlocks supports the concept of ",(0,i.kt)("a",{parentName:"p",href:"https://statecharts.dev/glossary/compound-state.html"},"compound states")," (also known as composite states) as defined by statecharts. A compound state is simply a state which contains more than one state inside it."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"States can define themselves in terms of other existing states, only accounting for the changes between them. Coding-by-difference like this helps prevents duplicate logic and ensure correctness.")),(0,i.kt)(p,{src:n(9504).Z,alt:"Logic block visual diagram",widthOverride:"380px",mdxType:"FancyImage"}),(0,i.kt)("p",null,"To create a compound state with LogicBlocks, simply create a state record that inherits from another state type."),(0,i.kt)("p",null,"Below is an example of a logic block that defines a few compound states."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'[Meta, LogicBlock(typeof(State))]\npublic partial class ExerciseLogic : LogicBlock<ExerciseLogic.State> {\n  public override Transition GetInitialState() => To<Standing>();\n\n  public abstract record State : StateLogic<State>;\n\n  public abstract record Active : State {\n    public Active() {\n      this.OnEnter(() => Console.WriteLine("Active"));\n    }\n\n    public record Walking : Active {\n      public Walking() {\n        this.OnEnter(() => Console.WriteLine("Walking"));\n      }\n    }\n\n    public record Running : Active {\n      public Running() {\n        this.OnEnter(() => Console.WriteLine("Running"));\n      }\n    }\n  }\n\n  public abstract record Inactive : State {\n    public Inactive() {\n      this.OnEnter(() => Console.WriteLine("Inactive"));\n    }\n\n    public record Standing : Inactive {\n      public Standing() {\n        this.OnEnter(() => Console.WriteLine("Inactive"));\n      }\n    }\n  }\n}\n')),(0,i.kt)("p",null,"Note how ",(0,i.kt)("inlineCode",{parentName:"p"},"Walking")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Running")," are inherit from the same parent state, ",(0,i.kt)("inlineCode",{parentName:"p"},"Active"),". Likewise, ",(0,i.kt)("inlineCode",{parentName:"p"},"Standing")," inherits from the ",(0,i.kt)("inlineCode",{parentName:"p"},"Inactive")," state. The parent states ",(0,i.kt)("inlineCode",{parentName:"p"},"Active")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"InActive")," are both compound states."),(0,i.kt)("p",null,"We have chosen to make the ",(0,i.kt)("inlineCode",{parentName:"p"},"Active")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Inactive")," states abstract since we plan to always be in one of the concrete states that inherit from them. You can decide whether or not to make a state abstract or not based on your desired behavior for your logic block."),(0,i.kt)(p,{src:n(9123).Z,alt:"Logic block visual diagram",widthOverride:"380px",mdxType:"FancyImage"}),(0,i.kt)("p",null,"States that inherit from other states will register their attach/detach and enter/exit callbacks in the order that the C# constructors are executed: from base type to most derived type. Internally, LogicBlocks exploits this C# constructor call order to infer the type hierarchy of a given state."),(0,i.kt)("p",null,"When the example state machine shown above is started, the initial state is ",(0,i.kt)("inlineCode",{parentName:"p"},"Standing"),", which inherits from the ",(0,i.kt)("inlineCode",{parentName:"p"},"Inactive")," state. When entered, each of the entrance callbacks registered by the base type ",(0,i.kt)("inlineCode",{parentName:"p"},"Inactive")," and the derived type ",(0,i.kt)("inlineCode",{parentName:"p"},"Standing")," will be invoked."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"logic.Start();\n\n// Prints:\n// Inactive\n// Standing\n")),(0,i.kt)("p",null,"If the ",(0,i.kt)("inlineCode",{parentName:"p"},"Standing")," state were to receive an input that causes it to transition to ",(0,i.kt)("inlineCode",{parentName:"p"},"Walking"),", the entire state hierarchy would change and all of the entrance callbacks for ",(0,i.kt)("inlineCode",{parentName:"p"},"Walking")," would execute:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"Active\nWalking\n")),(0,i.kt)("p",null,"Transitioning from ",(0,i.kt)("inlineCode",{parentName:"p"},"Walking")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Running"),", however, will result in only the following being printed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"Running\n")),(0,i.kt)("p",null,"Because the ",(0,i.kt)("inlineCode",{parentName:"p"},"Running")," state also inherits from the ",(0,i.kt)("inlineCode",{parentName:"p"},"Active")," state, transitioning between one ",(0,i.kt)("inlineCode",{parentName:"p"},"Active")," state (",(0,i.kt)("inlineCode",{parentName:"p"},"Walking"),") to another ",(0,i.kt)("inlineCode",{parentName:"p"},"Active")," state (",(0,i.kt)("inlineCode",{parentName:"p"},"Running"),") only results in the entrance callbacks being invoked for the portion of the state hierarchy that has changed \u2014 i.e., only the callbacks for each subtype of the last common ancestor type."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"LogicBlocks determines which entrance/exit callbacks to run when changing states, and only calls the entrance or exit callbacks that actually apply to the state transition. This behavior is consistent with the statechart requirements for ",(0,i.kt)("a",{parentName:"p",href:"https://statecharts.dev/glossary/compound-state.html"},"compound states"),":"),(0,i.kt)("blockquote",{parentName:"admonition"},(0,i.kt)("p",{parentName:"blockquote"},"When a substate transitions to another substate, both \u201cinside\u201d the compound state, the compound state does not exit or enter; it remains active.\n:::")),(0,i.kt)("h3",{parentName:"admonition",id:"\ufe0f-adding-inputs-to-force-a-state-change"},"\u2699\ufe0f Adding Inputs to Force a State Change"),(0,i.kt)("p",{parentName:"admonition"},"Attach and detach callbacks are especially useful for subscribing to services and disposing of subscriptions.")),(0,i.kt)("p",null,"For best results, don't add inputs during lifecycle callbacks. Instead, use them in handlers for services you're subscribed to, as shown above.\n:::"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public record MyState : State, IGet<Input.SomethingHappened> {\n  public MyState() {\n    OnAttach(() => Get<ISomeService>().DataReceived += OnDataReceived)\n    OnDetach(() => Get<ISomeService>().DataReceived -= OnDataReceived)\n  }\n\n  private void OnDataReceived(int data) {\n    // Trigger an input on the logic block that owns us \u2014 this can force a\n    // state change reactively if we know we can handle this type of input.\n    Input(new Input.SomethingHappened(data));\n  }\n\n  public Transition On(in Input.SomethingHappened input) => To<OtherState>();\n}\n")),(0,i.kt)("p",null,"We add an input to the logic block we are attached to from the handler of the event we subscribed to using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Input<T>()")," method provided by the state. We also implement the input handler for that event, which allows us to return a new state \u2014 effectively forcing the logic block to change states when something happens. This pattern is commonly leveraged with logic blocks to create complex reactive behaviors."),(0,i.kt)("h3",{id:"-attach-and-detach-vs-entrance-and-exit"},"\ud83e\udd4a Attach and Detach vs Entrance and Exit"),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Unlike entrance and exit callbacks, attach and detach callbacks ",(0,i.kt)("strong",{parentName:"p"},"always")," run for ",(0,i.kt)("em",{parentName:"p"},"each state instance")," that the logic block transitions to.")),(0,i.kt)("p",null,"Because ",(0,i.kt)("strong",{parentName:"p"},"attach and detach")," callbacks are invoked for each state instance, ",(0,i.kt)("em",{parentName:"p"},"they should only be used for housekeeping"),": i.e., subscribing and unsubscribing from events, notifications or other observables."),(0,i.kt)("p",null,"Likewise, ",(0,i.kt)("strong",{parentName:"p"},"entrance and exit")," callbacks ",(0,i.kt)("em",{parentName:"p"},"should not manage subscriptions"),", as the type hierarchy can remain mostly unchanged but the actual state instance can be different."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"In general, place instance-specific initialization or cleanup in ",(0,i.kt)("inlineCode",{parentName:"p"},"OnAttach")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"OnDetach"),". Likewise, place game or business related logic in ",(0,i.kt)("inlineCode",{parentName:"p"},"this.OnEnter")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"this.OnExit"),".")))}u.isMDXComponent=!0},9123:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/call_order-63e0c35577c58a0b0b981426b4d630a3.png"},9504:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/compound-62c9d5faa1c4bc525a7dc2916c1eda74.png"}}]);