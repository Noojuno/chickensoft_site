"use strict";(self.webpackChunkchickensoft_site=self.webpackChunkchickensoft_site||[]).push([[7874],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(a),u=r,h=d["".concat(l,".").concat(u)]||d[u]||m[u]||i;return a?n.createElement(h,o(o({ref:t},p),{},{components:a})):n.createElement(h,o({ref:t},p))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},894:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const i={title:"\ud83e\udd28 Why Logic Blocks?",image:"./header.jpg"},o=void 0,s={unversionedId:"logic_blocks/why",id:"logic_blocks/why",title:"\ud83e\udd28 Why Logic Blocks?",description:"This article explains why you might want to use LogicBlocks to manage state in your game or application.",source:"@site/docs/logic_blocks/01_why.md",sourceDirName:"logic_blocks",slug:"/logic_blocks/why",permalink:"/docs/logic_blocks/why",draft:!1,editUrl:"https://github.com/chickensoft-games/chickensoft_site/tree/main/docs/logic_blocks/01_why.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"\ud83e\udd28 Why Logic Blocks?",image:"./header.jpg"},sidebar:"tutorialSidebar",previous:{title:"\ud83d\udca1 LogicBlocks",permalink:"/docs/logic_blocks/"},next:{title:"\ud83d\udce6 Installation",permalink:"/docs/logic_blocks/installation"}},l={image:a(1266).Z},c=[{value:"\u2705 Goals",id:"-goals",level:2},{value:"\ud83d\udca1 Correct Hierarchical State Lifecycles",id:"-correct-hierarchical-state-lifecycles",level:2}],p={toc:c};function m(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This article explains why you might want to use LogicBlocks to manage state in your game or application."),(0,r.kt)("h2",{id:"-goals"},"\u2705 Goals"),(0,r.kt)("p",null,"LogicBlocks was designed in accordance with Chickensoft's development ",(0,r.kt)("a",{parentName:"p",href:"/philosophy"},"philosophy"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\ud83c\udf43 Flexible",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Simple to refactor as requirements change"),(0,r.kt)("li",{parentName:"ul"},"States can be easily reorganized and shared between logic blocks"),(0,r.kt)("li",{parentName:"ul"},"Visually compare refactors at a glance by checking generated diagrams"))),(0,r.kt)("li",{parentName:"ul"},"\ud83d\ude80 Performant",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Zero heap allocations if number of inputs do not exceed the cache size"),(0,r.kt)("li",{parentName:"ul"},"Works in ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/dotnet/corert/blob/master/Documentation/using-corert/reflection-free-mode.md"},"reflection-free mode")),(0,r.kt)("li",{parentName:"ul"},"Works when compiled ahead-of-time (AOT) for platforms like iOS"))),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udcaf Correct",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Programming by difference: define only the differences between states"),(0,r.kt)("li",{parentName:"ul"},"Less code == easier to verify"),(0,r.kt)("li",{parentName:"ul"},"Synchronous, ordered input processing for single threaded game logic"),(0,r.kt)("li",{parentName:"ul"},"Diagrams are generated from the code, not the other way around"),(0,r.kt)("li",{parentName:"ul"},"Run-to-completion (RTC): inputs processed immediately and synchronously"))),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udc40 Observable",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Observers can listen to outputs without knowing about states"),(0,r.kt)("li",{parentName:"ul"},"Observers are invoked synchronously in the order they were registered"))),(0,r.kt)("li",{parentName:"ul"},"\ud83e\udd13 Readable",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Use existing OOP concepts: state pattern, inheritance, interfaces"),(0,r.kt)("li",{parentName:"ul"},"Declarative: define all possible states, inputs, and outputs"))),(0,r.kt)("li",{parentName:"ul"},"\ud83d\uddbc\ufe0f Visualizable",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Diagrams are generated from code, not the other way around"),(0,r.kt)("li",{parentName:"ul"},"Diagrams are never out-of-date"))),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udcbe Serializable",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"First-party support for polymorphic state and data serialization to JSON"),(0,r.kt)("li",{parentName:"ul"},"AOT-friendly: serialization uses a source generator, not reflection"),(0,r.kt)("li",{parentName:"ul"},"Serialization can be combined with System.Text.Json generated contexts"))),(0,r.kt)("li",{parentName:"ul"},"\u2705 Testable",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Utilities included to make testing states easy"),(0,r.kt)("li",{parentName:"ul"},"Logic blocks themselves can be mocked")))),(0,r.kt)("h2",{id:"-correct-hierarchical-state-lifecycles"},"\ud83d\udca1 Correct Hierarchical State Lifecycles"),(0,r.kt)("p",null,"LogicBlocks guarantees correctness when executing hierarchical state lifecycle callbacks: i.e., entrance and exit callbacks for ",(0,r.kt)("a",{parentName:"p",href:"https://statecharts.dev/glossary/compound-state.html"},"compound states")," (also known as composite states) are ",(0,r.kt)("strong",{parentName:"p"},"guaranteed to run only when the relevant part of the state hierarchy changes.")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Hierarchical states are represented by making a state that inherits from another state using traditional C# inheritance."),(0,r.kt)("p",{parentName:"admonition"},"In terms of code, compound (or composite) states are simply states that are inherited from by other state types. When a state inherits from another state, it becomes a substate of that state. Otherwise, a state is known as an ",(0,r.kt)("a",{parentName:"p",href:"https://statecharts.dev/glossary/atomic-state.html"},"atomic")," (or simple) state."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"  public record ChildState : ParentState { /* ... */ }\n"))),(0,r.kt)("mermaid",{value:'stateDiagram-v2\nstate "Heater State" as Chickensoft_LogicBlocks_DiagramGenerator_Tests_TestCases_Heater_State {\n  state "Powered" as Chickensoft_LogicBlocks_DiagramGenerator_Tests_TestCases_Heater_State_Powered {\n    state "Idle" as Chickensoft_LogicBlocks_DiagramGenerator_Tests_TestCases_Heater_State_Idle\n    state "Heating" as Chickensoft_LogicBlocks_DiagramGenerator_Tests_TestCases_Heater_State_Heating\n  }\n  state "Off" as Chickensoft_LogicBlocks_DiagramGenerator_Tests_TestCases_Heater_State_Off\n}\n\n[*] --\x3e Chickensoft_LogicBlocks_DiagramGenerator_Tests_TestCases_Heater_State_Off'}),(0,r.kt)("p",null,"Any entrance or exit callbacks registered by the ",(0,r.kt)("inlineCode",{parentName:"p"},"Powered")," state wouldn't be invoked when transitioning from ",(0,r.kt)("inlineCode",{parentName:"p"},"Idle")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"Heating"),", since they are both ",(0,r.kt)("inlineCode",{parentName:"p"},"Powered")," states."),(0,r.kt)("p",null,"On the other hand, changing from any of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Powered")," states to ",(0,r.kt)("inlineCode",{parentName:"p"},"Off")," would result in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Powered")," state's exit callbacks being invoked. Likewise, entering a ",(0,r.kt)("inlineCode",{parentName:"p"},"Powered")," state from ",(0,r.kt)("inlineCode",{parentName:"p"},"Off")," would trigger the ",(0,r.kt)("inlineCode",{parentName:"p"},"Powered")," state's entrance callbacks."),(0,r.kt)("p",null,'LogicBlocks differentiates between "attaching" a state and "entering" a state. Attaching a state is based on the actual state instance changing, while entering is based on the state type changing. Attach and detach callbacks are always invoked every time the state changes, whereas entrance and exit callbacks respect the type hierarchy.'),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"For best results, place housekeeping operations in attach and detach callbacks, and game or business related logic in entrance and exit callbacks. More on this ",(0,r.kt)("a",{parentName:"p",href:"./basics/states#-attach-and-detach-vs-entrance-and-exit"},"here"),".")))}m.isMDXComponent=!0},1266:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/header-3b16a21d739396967ca870ae00925c8e.jpg"}}]);