"use strict";(self.webpackChunkchickensoft_site=self.webpackChunkchickensoft_site||[]).push([[3403],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),g=o,h=p["".concat(l,".").concat(g)]||p[g]||u[g]||i;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},2261:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));const i={title:"\ud83d\udd04 Testing States",image:"../header.jpg"},r=void 0,s={unversionedId:"logic_blocks/testing/testing_states",id:"logic_blocks/testing/testing_states",title:"\ud83d\udd04 Testing States",description:"Logic block states can easily be unit tested by themselves. To understand how to test a state, you need to know a little bit about its underlying context.",source:"@site/docs/logic_blocks/06_testing/02_testing_states.md",sourceDirName:"logic_blocks/06_testing",slug:"/logic_blocks/testing/testing_states",permalink:"/docs/logic_blocks/testing/testing_states",draft:!1,editUrl:"https://github.com/chickensoft-games/chickensoft_site/tree/main/docs/logic_blocks/06_testing/02_testing_states.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"\ud83d\udd04 Testing States",image:"../header.jpg"},sidebar:"tutorialSidebar",previous:{title:"\ud83d\udca1 Testing Logic Blocks",permalink:"/docs/logic_blocks/testing/testing_logic_blocks"},next:{title:"\ud83e\udea2 Testing Bindings",permalink:"/docs/logic_blocks/testing/testing_bindings"}},l={},c=[{value:"\ud83d\udd75\ufe0f Understanding the Context",id:"\ufe0f-understanding-the-context",level:2},{value:"\ud83e\udd78 Faking the Context",id:"-faking-the-context",level:2},{value:"\ud83d\udeaa Testing Entrance and Exit",id:"-testing-entrance-and-exit",level:2},{value:"\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d\udc68 Testing Attachment",id:"\ufe0f-testing-attachment",level:2}],d={toc:c};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Logic block states can easily be unit tested by themselves. To understand how to test a state, you need to know a little bit about its underlying context."),(0,o.kt)("h2",{id:"\ufe0f-understanding-the-context"},"\ud83d\udd75\ufe0f Understanding the Context"),(0,o.kt)("p",null,"Each logic block state has an internal ",(0,o.kt)("inlineCode",{parentName:"p"},"context")," which wraps the logic block it is attached to."),(0,o.kt)("p",null,"Behind the scenes, calling the state's ",(0,o.kt)("inlineCode",{parentName:"p"},"Input"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Output"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Get"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"AddError"),' methods will manipulate the context (and by extent the logic block). Attempting to call those state methods when not attached to a logic block results in the state throwing an exception regarding an "uninitialized context." This most commonly happens if you reference one of those methods in the state\'s constructor instead of in the relevant lifecycle callbacks, since the state is not attached at the time it is constructed.'),(0,o.kt)("h2",{id:"-faking-the-context"},"\ud83e\udd78 Faking the Context"),(0,o.kt)("p",null,"LogicBlocks allows you to create a fake context for testing purposes. The fake context has its own blackboard, and allows you to collect inputs, outputs, and errors added by the state."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"[Fact]\npublic void PlaysBeepingSoundOnEnter() {\n  var state = new Timer.State.PoweredOn.Beeping();\n\n  // Create a fake context for testing purposes.\n  var context = state.CreateFakeContext();\n\n  // Simulate the state being entered.\n  state.Enter();\n\n  // Verify that the state produced the outputs we expect.\n  context.Outputs.ShouldBe([new Timer.Output.PlayBeepingSound()]);\n}\n")),(0,o.kt)("p",null,"You can also verify inputs and errors in the same way via ",(0,o.kt)("inlineCode",{parentName:"p"},"context.Inputs")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"context.Errors"),"."),(0,o.kt)("p",null,"Here's another example where we add a dependency to the fake context's blackboard. This allows us to swap the dependencies a state uses during testing."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"[Fact]\npublic void ChangesDuration() {\n  var state = new Timer.State.PoweredOn.Idle();\n\n  var context = state.CreateFakeContext();\n\n  // Put a value on the blackboard for the state to use.\n  context.Set(new Timer.Data() { Duration = 30.0d });\n\n  var duration = 45;\n\n  state.On(new Timer.Input.ChangeDuration(duration))\n    .State\n    .ShouldBeOfType<Timer.State.PoweredOn.Idle>();\n\n  context.Get<Timer.Data>().Duration.ShouldBe(duration);\n}\n")),(0,o.kt)("h2",{id:"-testing-entrance-and-exit"},"\ud83d\udeaa Testing Entrance and Exit"),(0,o.kt)("p",null,"Entrance and exit callbacks can be invoked manually by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"Enter()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Exit()")," on the state."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"var context = state.CreateFakeContext();\n\n// Simulate the state being entered.\nstate.Enter();\n\n// Simulate the state being exited.\nstate.Exit();\n")),(0,o.kt)("p",null,"Sometimes you only want to invoke entrance and exit callbacks that apply to a certain subsection of the state's type hierarchy to avoid simulating side effects (like outputs) outputted by its base classes."),(0,o.kt)("p",null,"To accomplish this, pass in a parent state type. The parent state and its ancestor callbacks will be ignored, allowing you to simulate just the substate callbacks that you care about."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"var state = new Timer.State.PoweredOn.Idle();\n\n// If PoweredOn had entrance callbacks, they wouldn't be run. This only runs\n// the entrance callbacks for Idle, if any.\nstate.Enter<Timer.State.PoweredOn>();\n// Same as above, but for exiting.\nstate.Exit<Timer.State.PoweredOn>();\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Passing in a parent state type is optional and usually only done when testing a state that's derived from another state that you have other unit tests for.")),(0,o.kt)("h2",{id:"\ufe0f-testing-attachment"},"\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d\udc68 Testing Attachment"),(0,o.kt)("p",null,"You can easily invoke a state's attach and detach callbacks by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"Attach()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Detach()")," on the state."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"var state = new Timer.State.PoweredOn.Idle();\n\nvar context = state.CreateFakeContext();\n\n// Simulate the state being attached to a logic block.\nstate.Attach();\n\n// Simulate the state being detached from a logic block.\nstate.Detach();\n")))}u.isMDXComponent=!0}}]);