"use strict";(self.webpackChunkchickensoft_site=self.webpackChunkchickensoft_site||[]).push([[967],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(a),m=i,y=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return a?n.createElement(y,r(r({ref:t},c),{},{components:a})):n.createElement(y,r({ref:t},c))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},1970:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>g,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const o={title:"Serialization for C# Games",description:"Build complex state preservation systems for implementing game save systems or custom netcode with Chickensoft's new serialization tools.\n",slug:"serialization-for-csharp-games",image:"./header.jpg",keywords:["Godot","C#","serialization","netcode","save","load","save system","loading games","reading game data","loading game data",2024,"game design","game engine","Unity","indie game development","open source","foss","programming language","game development","scripting","performance optimization","syntax comparison","cross-platform","community support","tutorials","game engine features","2D game development","3D game development","game development tips","game programming","game publishing","software architecture","architecture"],authors:["joanna"]},r=void 0,s={permalink:"/blog/serialization-for-csharp-games",source:"@site/blog/2024-06-11-serialization-for-csharp-games/index.md",title:"Serialization for C# Games",description:"Build complex state preservation systems for implementing game save systems or custom netcode with Chickensoft's new serialization tools.\n",date:"2024-06-11T00:00:00.000Z",formattedDate:"June 11, 2024",tags:[],readingTime:14.23,hasTruncateMarker:!0,authors:[{name:"Joanna",title:"Chickensoft Organizer",url:"/authors/joanna",imageURL:"/img/authors/joanna.jpg",key:"joanna"}],frontMatter:{title:"Serialization for C# Games",description:"Build complex state preservation systems for implementing game save systems or custom netcode with Chickensoft's new serialization tools.\n",slug:"serialization-for-csharp-games",image:"./header.jpg",keywords:["Godot","C#","serialization","netcode","save","load","save system","loading games","reading game data","loading game data","2024","game design","game engine","Unity","indie game development","open source","foss","programming language","game development","scripting","performance optimization","syntax comparison","cross-platform","community support","tutorials","game engine features","2D game development","3D game development","game development tips","game programming","game publishing","software architecture","architecture"],authors:["joanna"]},prevItem:{title:"Display Scaling in Godot 4",permalink:"/blog/display-scaling"},nextItem:{title:"Using Godot with C# in 2024",permalink:"/blog/godot-csharp-2024"}},l={image:a(2272).Z,authorsImageUrls:[void 0]},p=[{value:"\ud83e\udea4 The Serialization Trap",id:"-the-serialization-trap",level:2},{value:"\ud83e\uddd1\u200d\u2695\ufe0f Serialization for Everyone",id:"\ufe0f-serialization-for-everyone",level:2},{value:"\ud83d\udcbe What Makes a Good Save System?",id:"-what-makes-a-good-save-system",level:2},{value:"\ud83d\ude4b\u200d\u2640\ufe0f Why Make a Serializer? ",id:"\ufe0f-why-make-a-serializer-",level:2},{value:"\ud83d\udd2e Generating Metadata at Build Time",id:"-generating-metadata-at-build-time",level:3},{value:"\ud83d\udd2e Introducing the Introspection Generator",id:"-introducing-the-introspection-generator",level:2},{value:"\ud83d\udce6 Introducing the Serialization System",id:"-introducing-the-serialization-system",level:2},{value:"\ud83e\udd16 Godot-Specific Serialization",id:"-godot-specific-serialization",level:2},{value:"\ud83d\udc7d Introducing SaveFileBuilder",id:"-introducing-savefilebuilder",level:2},{value:"\ud83d\udca1 Serializing Hierarchical State Machines",id:"-serializing-hierarchical-state-machines",level:2},{value:"\ud83d\udc89 A Better AutoInject",id:"-a-better-autoinject",level:2},{value:"\ud83d\udd79\ufe0f Saving &amp; Loading in the Game Demo",id:"\ufe0f-saving--loading-in-the-game-demo",level:2},{value:"Conclusion",id:"conclusion",level:2}],c=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},d=c("FancyImage"),u=c("Spacer"),m=c("GithubCard"),y=c("BlogDiscordInvite"),h={toc:p};function g(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,n.Z)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(d,{src:a(6427).Z,alt:"Article header image. Balloons with icons inside representing the new packages and updates.",mdxType:"FancyImage"}),(0,i.kt)("p",null,'Serialization is incredibly important to games, and often painfully difficult to implement well. Unless you just like building serializers, you may find yourself putting off developing a save/load system, especially if you need more than just a simple "what level am I on?" mechanism.'),(0,i.kt)("h2",{id:"-the-serialization-trap"},"\ud83e\udea4 The Serialization Trap"),(0,i.kt)("p",null,"Like compilers, game engines, video games, and operating systems, serialization is a bit of a siren's call for programming enthusiasts. It seems easy at first:\xa0just write some data to a file \u2014 done!"),(0,i.kt)("p",null,"But...what do you do with the data once you read it back from the file? What if the save file is outdated and your models have changed? How do you reconstruct a hierarchical state machine? What about translating saved data into polymorphic models that describe your game? And if you manage to solve that, how do you pass them through the scene tree to rehydrate your game's save state?"),(0,i.kt)("h2",{id:"\ufe0f-serialization-for-everyone"},"\ud83e\uddd1\u200d\u2695\ufe0f Serialization for Everyone"),(0,i.kt)("p",null,"For the last 6 months, I've been exploring answers to the questions above. I am releasing 3 major updates to existing packages, as well as 4 completely new packages that I'm really excited to share with you."),(0,i.kt)(d,{src:a(2462).Z,alt:"Balloons with package icons and the text 'Summer 2024 Update: Serialization for C# Games",mdxType:"FancyImage"}),(0,i.kt)("p",null,"There's a better way to make games now \u2014\xa0with a fully open source stack. If this sounds interesting to you, strap in \u2014\xa0it's going to be a long ride."),(0,i.kt)("h2",{id:"-what-makes-a-good-save-system"},"\ud83d\udcbe What Makes a Good Save System?"),(0,i.kt)("p",null,"A good save system, in my opinion, should meet the following criteria:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\ud83d\udd2e Works when compiled ahead-of-time. A general purpose serialization toolchain needs to work on the lowest common denominator of platforms \u2014 iOS."),(0,i.kt)("p",{parentName:"li"},"AOT is a steep requirement for serialization, as it essentially condemns you to generating metadata about types at build time.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\ud83d\udd18 Opt-in by default. Sometimes you want to extend a non-serializable class that you don't control and make it serializable.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2935\ufe0f Polymorphic deserialization. It needs to be easy to deserialize explicit implementations of an abstract type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\ud83d\udd04 Collections. Even if you don't intend to support generic types, properly implementing collections is non-trivial.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\ud83d\udce6 Versioning. Models change as a game evolves, and you don't want to break existing save files.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\ud83e\ude9d Serialization Hooks \u2014 for types with custom serialization logic or types outside the assembly whose metadata can't be generated."))),(0,i.kt)("p",null,"Now that we know what a good serialization system looks like, let's talk about how its done."),(0,i.kt)("h2",{id:"\ufe0f-why-make-a-serializer-"},"\ud83d\ude4b\u200d\u2640\ufe0f Why Make a Serializer? ",(0,i.kt)("sup",{parentName:"h2",id:"fnref-1-82b6b8"},(0,i.kt)("a",{parentName:"sup",href:"#fn-1-82b6b8",className:"footnote-ref"},"1"))),(0,i.kt)("p",null,"The .NET ecosystem has slowly begun to embrace an AOT-friendly world, and System.Text.Json can now generate metadata about types at build time."),(0,i.kt)("p",null,"The new serialization system we've introduced is built on top of System.Text.Json. Because of this shared foundation, it can interop seamlessly with existing generated JSON contexts and converters."),(0,i.kt)("p",null,"Why build a new serializer on top of System.Text.Json if it can already do AOT serialization just fine? Unfortunately, System.Text.Json has a few pain points:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Doesn't help with versioning.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Derived types are painful \u2014\xa0you have to manually register them on the base type."),(0,i.kt)("p",{parentName:"li"},"Essentially, you have to keep a registry of all derived types in a place unrelated to the type itself. Manually tracking types is incredibly error-prone and hostile to refactoring type hierarchies \u2014 a common activity if you're using hierarchial state machines.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Doesn't support serialization hooks. You have to make a custom converter for every type that needs custom serialization logic."))),(0,i.kt)("p",null,"Since we are designing for a specific use case \u2014 saving and loading game files \u2014 we can make a solution that's tailored to exactly that. Plus, we can still leverage the amazing foundation that System.Text.Json provides."),(0,i.kt)("h3",{id:"-generating-metadata-at-build-time"},"\ud83d\udd2e Generating Metadata at Build Time"),(0,i.kt)("p",null,"If we're going to make an AOT-friendly serialization system, we're going to need metadata about types. We've already established that the metadata generated by System.Text.Json requires us to write rather unfriendly code that is going to be a pain to refactor, so we can't rely on the System.Text.Json source generator."),(0,i.kt)("p",null,"We're going to have to make our own."),(0,i.kt)("h2",{id:"-introducing-the-introspection-generator"},"\ud83d\udd2e Introducing the Introspection Generator"),(0,i.kt)("p",null,"The new ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/Introspection"},"Introspection")," generator is now the backbone of all the major Chickensoft libraries that need metaprogramming capabilities. It automatically generates a registry of every type that is visible from the global scope, including nested types."),(0,i.kt)(u,{mdxType:"Spacer"},(0,i.kt)(m,{profile:"chickensoft-games",repo:"Introspection",logo:"/img/chickensoft/introspection.png",mdxType:"GithubCard"})),(0,i.kt)("details",null,(0,i.kt)("summary",null,(0,i.kt)("code",null,"TypeRegistry.g.cs")," Example"),(0,i.kt)("p",null,"An abbreviated version of the entries in a generated type registry. Not particularly interesting unless you just like writing serializers."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The generic form of ",(0,i.kt)("inlineCode",{parentName:"p"},"Activator.CreateInstance<T>")," works well (and is performant) in both AOT and JIT scenarios. I verified this by emailing Michal Strehovsk\xfd, the .NET compiler engineer ",(0,i.kt)("a",{parentName:"p",href:"https://x.com/MStrehovsky/status/1231673490551582721"},"who overhauled it"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'[typeof(PartialModel)] = new IdentifiableTypeMetadata("PartialModel", (r) => r.Receive<PartialModel>(), () => System.Activator.CreateInstance<PartialModel>(), new PartialModel.MetatypeMetadata(), "multiple_partial_definitions", 1),\n[typeof(PropertyModel)] = new AbstractIntrospectiveTypeMetadata("PropertyModel", (r) => r.Receive<PropertyModel>(), new PropertyModel.MetatypeMetadata()),\n[typeof(SomeType)] = new IntrospectiveTypeMetadata("SomeType", (r) => r.Receive<SomeType>(), () => System.Activator.CreateInstance<SomeType>(), new SomeType.MetatypeMetadata(), 1),\n[typeof(StaticPropertyIsSkipped)] = new IntrospectiveTypeMetadata("StaticPropertyIsSkipped", (r) => r.Receive<StaticPropertyIsSkipped>(), () => System.Activator.CreateInstance<StaticPropertyIsSkipped>(), new StaticPropertyIsSkipped.MetatypeMetadata(), 1),\n[typeof(TraditionalNamespace.A)] = new ConcreteTypeMetadata("A", (r) => r.Receive<TraditionalNamespace.A>(), () => System.Activator.CreateInstance<TraditionalNamespace.A>()),\n[typeof(TraditionalNamespace.A.AA)] = new ConcreteTypeMetadata("AA", (r) => r.Receive<TraditionalNamespace.A.AA>(), () => System.Activator.CreateInstance<TraditionalNamespace.A.AA>()),\n'))),(0,i.kt)("p",null,"Better yet, the new Introspection generator is designed for performance: it generates all of its data without using any analyzer symbol data \u2014\xa0just the syntax tree \u2014 making it pretty dang fast. It also deprecates our previous generator, ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/SuperNodes"},"SuperNodes"),", that was not as capable or performant."),(0,i.kt)("p",null,"You can read all about it on the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/Introspection"},"Introspection")," repository. The general idea is that it allows you to tag types that are introspective with the ",(0,i.kt)("inlineCode",{parentName:"p"},"[Meta]")," attribute. Introspective types have additional metadata generated about them, including their attribute information, their properties, and the attributes on their properties, among other things."),(0,i.kt)("details",null,(0,i.kt)("summary",null,(0,i.kt)("code",null,"IntrospectiveType.g.cs")," Example"),(0,i.kt)("p",null,"An abbreviated version of the generated metadata for an introspective type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'  [ExcludeFromCodeCoverage]\n  public MixinBlackboard MixinState { get; } = new();\n\n  [ExcludeFromCodeCoverage]\n  public IMetatype Metatype => ((IIntrospectiveTypeMetadata)Types.Graph.GetMetadata(typeof(IntrospectiveType))).Metatype;\n\n  public class MetatypeMetadata : IMetatype {\n    [ExcludeFromCodeCoverage]\n    public System.Type Type => typeof(IntrospectiveType);\n    [ExcludeFromCodeCoverage]\n    public bool HasInitProperties { get; } = true;\n\n    [ExcludeFromCodeCoverage]\n    public IReadOnlyList<PropertyMetadata> Properties { get; } = new List<PropertyMetadata>() {\n      new PropertyMetadata(\n        Name: "Address",\n        IsInit: false,\n        IsRequired: false,\n        Getter: (object obj) => ((IntrospectiveType)obj).Address,\n        Setter: (object obj, object? value) => ((IntrospectiveType)obj).Address = (string)value,\n        GenericType: new GenericType(\n          OpenType: typeof(string),\n          ClosedType: typeof(string),\n          Arguments: System.Array.Empty<GenericType>(),\n          GenericTypeGetter: receiver => receiver.Receive<string>(),\n          GenericTypeGetter2: default\n        ),\n        Attributes: new Dictionary<System.Type, System.Attribute[]>() {\n          [typeof(TagAttribute)] = new System.Attribute[] {\n            new TagAttribute("address")\n          }\n        }\n      ),\n      new PropertyMetadata(\n        Name: "Age",\n        IsInit: true,\n        IsRequired: true,\n        Getter: (object obj) => ((IntrospectiveType)obj).Age,\n        Setter: null,\n        GenericType: new GenericType(\n          OpenType: typeof(int),\n          ClosedType: typeof(int),\n          Arguments: System.Array.Empty<GenericType>(),\n          GenericTypeGetter: receiver => receiver.Receive<int>(),\n          GenericTypeGetter2: default\n        ),\n        Attributes: new Dictionary<System.Type, System.Attribute[]>() {\n          [typeof(TagAttribute)] = new System.Attribute[] {\n            new TagAttribute("age")\n          }\n        }\n      ),\n      new PropertyMetadata(\n        Name: "Description",\n        IsInit: true,\n        IsRequired: false,\n        Getter: (object obj) => ((IntrospectiveType)obj).Description,\n        Setter: null,\n        GenericType: new GenericType(\n          OpenType: typeof(string),\n          ClosedType: typeof(string),\n          Arguments: System.Array.Empty<GenericType>(),\n          GenericTypeGetter: receiver => receiver.Receive<string>(),\n          GenericTypeGetter2: default\n        ),\n        Attributes: new Dictionary<System.Type, System.Attribute[]>() {\n          [typeof(TagAttribute)] = new System.Attribute[] {\n            new TagAttribute("description")\n          }\n        }\n      ),\n      new PropertyMetadata(\n        Name: "Name",\n        IsInit: true,\n        IsRequired: true,\n        Getter: (object obj) => ((IntrospectiveType)obj).Name,\n        Setter: null,\n        GenericType: new GenericType(\n          OpenType: typeof(string),\n          ClosedType: typeof(string),\n          Arguments: System.Array.Empty<GenericType>(),\n          GenericTypeGetter: receiver => receiver.Receive<string>(),\n          GenericTypeGetter2: default\n        ),\n        Attributes: new Dictionary<System.Type, System.Attribute[]>() {\n          [typeof(TagAttribute)] = new System.Attribute[] {\n            new TagAttribute("name")\n          }\n        }\n      )\n    };\n\n    [ExcludeFromCodeCoverage]\n    public IReadOnlyDictionary<System.Type, System.Attribute[]> Attributes { get; } = new Dictionary<System.Type, System.Attribute[]>() {\n      [typeof(IdAttribute)] = new System.Attribute[] {\n        new IdAttribute("init_args_model")\n      },\n      [typeof(MetaAttribute)] = new System.Attribute[] {\n        new MetaAttribute()\n      }\n    };\n\n    [ExcludeFromCodeCoverage]\n    public IReadOnlyList<System.Type> Mixins { get; } = new List<System.Type>() {\n    };\n\n    [ExcludeFromCodeCoverage]\n    public IReadOnlyDictionary<System.Type, System.Action<object>> MixinHandlers { get; } = new Dictionary<System.Type, System.Action<object>>() {\n    };\n\n\n    [ExcludeFromCodeCoverage]\n    public object Construct(IReadOnlyDictionary<string, object?>? args = null) {\n      args = args ?? throw new System.ArgumentNullException(nameof(args), "Constructing IntrospectiveType requires init args.");\n      return new IntrospectiveType() {\n        Address = args.ContainsKey("Address") ? (string)args["Address"] : default!,\n        Age = args.ContainsKey("Age") ? (int)args["Age"] : default!,\n        Description = args.ContainsKey("Description") ? (string)args["Description"] : default!,\n        Name = args.ContainsKey("Name") ? (string)args["Name"] : default!\n      };\n    }\n    [ExcludeFromCodeCoverage]\n    public override bool Equals(object obj) => true;\n    [ExcludeFromCodeCoverage]\n    public override int GetHashCode() => base.GetHashCode();\n  }\n'))),(0,i.kt)("p",null,"You don't have to fully understand the generated introspection data to appreciate it. Basically, it makes all the stuff you'd ever need to write a decently polymorphic serialization system."),(0,i.kt)("p",null,"\u2705 Now any serializer we build on top of this will work when compiled ahead of time \u2014\xa0done! Not so bad, right?"),(0,i.kt)("h2",{id:"-introducing-the-serialization-system"},"\ud83d\udce6 Introducing the Serialization System"),(0,i.kt)("p",null,"The new ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/Serialization"},"Serialization")," system builds off the Introspection generator, allowing you to define serializable types with relative ease."),(0,i.kt)(u,{mdxType:"Spacer"},(0,i.kt)(m,{profile:"chickensoft-games",repo:"Serialization",logo:"/img/chickensoft/serialization.png",mdxType:"GithubCard"})),(0,i.kt)("p",null,"It isn't as powerful as the System.Text.Json generators, but it's tailored for writing simple, refactor-friendly code."),(0,i.kt)("p",null,"Here's what a serializable game model looks like."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'using Chickensoft.Introspection;\nusing Chickensoft.Serialization;\nusing Godot;\n\n[Meta, Id("player_data")]\npublic partial record PlayerData {\n  [Save("global_transform")]\n  public required Transform3D GlobalTransform { get; init; }\n  [Save("state_machine")]\n  public required PlayerLogic StateMachine { get; init; }\n  [Save("velocity")]\n  public required Vector3 Velocity { get; init; }\n}\n')),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"[Id]"),' attribute tells the Introspection generator to generate additional metadata on top of the additional introspection data specific to "identifiable" types. The Serialization system and Introspection generator were designed in tandem, so they work together seamlessly, even though the Introspection generator has no knowledge of serialization. It just generates metadata.')),(0,i.kt)("p",null,"\u2705 Note how the serialization system is opt-in: just add the ",(0,i.kt)("inlineCode",{parentName:"p"},"[Save]")," attribute and specify a json key name for the properties you wish to persist!"),(0,i.kt)("p",null,"\u2705 It also works with collections. It provides support for the only 3 collections you should ever need when working with JSON: ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"List<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Dictionary<TKey, TValue>"),". If you need something else, you're doing it wrong. (Or you can just use the System.Text.Json generator and make a serialization context, if you must get fancy)."),(0,i.kt)("p",null,"\u2705 Oh, and it works with inheritance and abstract types, too. Check the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/Serialization"},"Serialization")," readme for more usage details."),(0,i.kt)("p",null,"\u2705 Oh, and of course \u2014 versioning! Here's what a versioned model looks like."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'[Meta, Id("log_entry")]\npublic abstract partial class LogEntry : SystemLogEntry { }\n\n[Meta, Version(1)]\npublic partial class LogEntry1 : LogEntry, IOutdated {\n  [Save("text")]\n  public required string Text { get; init; }\n\n  [Save("type")]\n  public required string Type { get; init; }\n\n  public object Upgrade(IReadOnlyBlackboard deps) => new LogEntry2() {\n    Text = Text,\n    Type = Type switch {\n      "info" => LogType.Info,\n      "warning" => LogType.Warning,\n      "error" or _ => LogType.Error,\n    }\n  };\n}\n\npublic enum LogType {\n  Info,\n  Warning,\n  Error\n}\n\n[Meta, Version(2)]\npublic partial class LogEntry2 : LogEntry {\n  [Save("text")]\n  public required string Text { get; init; }\n\n  [Save("type")]\n  public required LogType Type { get; init; }\n}\n')),(0,i.kt)("p",null,"The serialization system can even upgrade your out of date models while they're being deserialized, ensuring you never see an out-of-date type in your game logic."),(0,i.kt)("p",null,"\u2705 Finally, you can also implement custom serialization hooks on types that wish to customize how they are serialized. They have access to their JSON node, and can even return an entirely different object if they wish (as long as it is a derived type of the type being deserialized)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'  [Meta, Id("custom_serializable")]\n  public partial class CustomSerializable : ICustomSerializable {\n    public int Value { get; set; }\n\n    public object OnDeserialized(\n      IdentifiableTypeMetadata metadata,\n      JsonObject json,\n      JsonSerializerOptions options\n    ) {\n      Value = json["value"]?.GetValue<int>() ?? -1;\n\n      return this;\n    }\n\n    public void OnSerialized(\n      IdentifiableTypeMetadata metadata,\n      JsonObject json,\n      JsonSerializerOptions options\n    ) {\n      // Even though our property doesn\'t have the [Save] attribute, we\n      // can save it manually.\n      json["value"] = Value;\n    }\n  }\n')),(0,i.kt)("p",null,"\ud83e\udd73 Now we've met all of our serialization requirements."),(0,i.kt)("p",null,"\u2728 But wait, there's more! A LOT more."),(0,i.kt)("h2",{id:"-godot-specific-serialization"},"\ud83e\udd16 Godot-Specific Serialization"),(0,i.kt)("p",null,"We also need to be able to serialize Godot-specific types, like transforms, vectors, etc. Fortunately, there's a new package containing a few System.Text.Json converters that can convert Godot types to JSON and back."),(0,i.kt)(u,{mdxType:"Spacer"},(0,i.kt)(m,{profile:"chickensoft-games",repo:"Serialization.Godot",logo:"/img/chickensoft/package.png",mdxType:"GithubCard"})),(0,i.kt)("p",null,"It only supports a handful of types right now, so please \u2014 PLEASE \u2014 contribute to it if you can!"),(0,i.kt)("h2",{id:"-introducing-savefilebuilder"},"\ud83d\udc7d Introducing SaveFileBuilder"),(0,i.kt)("p",null,"Now that we can define beautiful, serializable models, how do we extract data from disparate nodes across the scene tree, and how do we return it to the relevant nodes (or create them) when we load the game?"),(0,i.kt)(u,{mdxType:"Spacer"},(0,i.kt)(m,{profile:"chickensoft-games",repo:"SaveFileBuilder",logo:"/img/chickensoft/save_file_builder.png",mdxType:"GithubCard"})),(0,i.kt)("p",null,"Meet SaveFileBuilder. It allows you to define a ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFile")," as a tree of ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveChunks"),". Each ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveChunk")," may have its own children chunks. You can access each child chunk by its type to recursively construct the save file (or load it)."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/AutoInject"},"AutoInject")," should be used to find the nearest parent save chunk in the scene tree so that the child chunk can add itself to the parent."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'SaveFile = new SaveFile<GameData>(\n  root: new SaveChunk<GameData>(\n    onSave: (chunk) => {\n      // Use root chunk to get child chunks that were added to us\n      // lower in the scene tree.\n      var gameData = new GameData() {\n        MapData = chunk.GetChunkSaveData<MapData>(),\n        PlayerData = chunk.GetChunkSaveData<PlayerData>(),\n        PlayerCameraData = chunk.GetChunkSaveData<PlayerCameraData>()\n      };\n\n      return gameData;\n    },\n    onLoad: (chunk, data) => {\n      // Break up the game data and send it to the child chunks so that\n      // they can load the data into the nodes they belong to.\n      chunk.LoadChunkSaveData(data.MapData);\n      chunk.LoadChunkSaveData(data.PlayerData);\n      chunk.LoadChunkSaveData(data.PlayerCameraData);\n    }\n  ),\n  onSave: async (GameData data) => {\n    // Save the game data to disk.\n    var json = JsonSerializer.Serialize(data, JsonOptions);\n    await FileSystem.File.WriteAllTextAsync(SaveFilePath, json);\n  },\n  onLoad: async () => {\n    // Load the game data from disk.\n    if (!FileSystem.File.Exists(SaveFilePath)) {\n      GD.Print("No save file to load :\'(");\n      return null;\n    }\n\n    var json = await FileSystem.File.ReadAllTextAsync(SaveFilePath);\n    return JsonSerializer.Deserialize<GameData>(json, JsonOptions);\n  }\n);\n')),(0,i.kt)("p",null,"In the future, this can be expanded on by creating an async variety. Asynchronicity would allow you to define save chunks that can split loading and saving into multiple operations, streamlining the most complex save scenarios imaginable."),(0,i.kt)("h2",{id:"-serializing-hierarchical-state-machines"},"\ud83d\udca1 Serializing Hierarchical State Machines"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/LogicBlocks"},"LogicBlocks"),", our hierarchical state machine implementation, is now fully serializable, thanks to the version 5 update that was just released. It integrates seamlessly with the new Introspection generator and Serialization system."),(0,i.kt)(u,{mdxType:"Spacer"},(0,i.kt)(m,{profile:"chickensoft-games",repo:"LogicBlocks",logo:"/img/chickensoft/logic_blocks.png",mdxType:"GithubCard"})),(0,i.kt)("p",null,"LogicBlocks 5 will now automatically preallocate states when constructed, thanks to the generated metadata that allows it to see every possible state ahead of time."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Unrelated, but the new performance updates LogicBlocks 5 receives also eliminates runtime memory allocations, except in scenarios where the number of inputs or input types exceeds the input buffer size.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'[Meta, Id("serializable_logic")]\n[LogicBlock(typeof(State), Diagram = true)]\npublic partial class MyLogicBlock : LogicBlock<MyLogicBlock.State> {\n  public override Transition GetInitialState() => To<State.PoweredOff>();\n\n  [Meta]\n  public abstract partial record State : StateLogic<State> {\n    [Meta, Id("serializable_logic_state_off")]\n    public partial record PoweredOff : State;\n\n    [Meta, Id("serializable_logic_state_on")]\n    public partial record PoweredOn : State;\n\n    [Meta, Id("serializable_logic_versioned_state")]\n    public abstract partial record VersionedState : State;\n\n    [Meta, Version(1)]\n    public partial record Version1 : VersionedState;\n\n    [Meta, Version(2)]\n    public partial record Version2 : VersionedState;\n  }\n}\n')),(0,i.kt)("p",null,"Oh \u2014\xa0and LogicBlocks now has an ",(0,i.kt)("a",{parentName:"p",href:"/docs/logic_blocks/"},"all new documentation site"),"! There's never been a better time to embrace the magic and rigor of statecharts."),(0,i.kt)("h2",{id:"-a-better-autoinject"},"\ud83d\udc89 A Better AutoInject"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/AutoInject"},"AutoInject")," is our node-based dependency injection system. It allows you to find dependencies by searching ancestor nodes for the first node that has the dependency you're looking for. It's as simple as it sounds, at least in theory (the devil is in the implementation details)."),(0,i.kt)(u,{mdxType:"Spacer"},(0,i.kt)(m,{profile:"chickensoft-games",repo:"AutoInject",logo:"/img/chickensoft/auto_inject.png",mdxType:"GithubCard"})),(0,i.kt)("p",null,"Previously, AutoInject was built on top of ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/SuperNodes"},"SuperNodes"),". Now that ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/SuperNodes"},"SuperNodes")," has been deprecated and replaced with the new ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/Introspection"},"Introspection")," generator, the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/PowerUps"},"PowerUps")," package (a set of mixins designed to work with AutoInject and SuperNodes) has also been deprecated. Fortunately, all of its functionality now lives inside AutoInject."),(0,i.kt)("p",null,"Like before, you can use the new ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/chickensoft-games/Introspection"},"Introspection")," generator to apply mixins. But, it's even simpler now \u2014 ",(0,i.kt)("em",{parentName:"p"},"all")," of the mixins available in AutoInject can be applied at once:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// Apply all of the AutoInject mixins at once:\n[Meta(typeof(IAutoNode))]\npublic partial class MyNode : Node { }\n")),(0,i.kt)("p",null,"That one little line above allows you to automatically bind nodes to properties, inject dependencies, provide dependencies, and use .NET-style notification callbacks and get additional lifecycle notifications that help with unit testing nodes, if that's your jam. Be sure to checkout the AutoInject repository for more details."),(0,i.kt)("h2",{id:"\ufe0f-saving--loading-in-the-game-demo"},"\ud83d\udd79\ufe0f Saving & Loading in the Game Demo"),(0,i.kt)("p",null,"Of course, no long-winded blog announcing a bunch of new packages would be complete without a demo. The Chickensoft Game Demo has been updated to version 3, and now includes full state persistence and restoration, thanks to all these new tools."),(0,i.kt)(u,{mdxType:"Spacer"},(0,i.kt)(m,{profile:"chickensoft-games",repo:"GameDemo",logo:"/img/chickensoft/game_demo.png",mdxType:"GithubCard"})),(0,i.kt)("p",null,"If you're still fuzzy on the details, go check out the code and take a closer look. There's also nearly 300 unit tests that can help show you how any particularly part of the code works, too."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"We'll close by celebrating the fact that Chickensoft has now reached a new layer of the gamedev hierarchy of needs: serialization. Now we can start solving the real problems."),(0,i.kt)(d,{src:a(3058).Z,alt:"Maslow's hierarchy of game development",mdxType:"FancyImage"}),(0,i.kt)("p",null,"If you made it this far, thanks for reading \u2014 and happy serializing!"),(0,i.kt)(y,{mdxType:"BlogDiscordInvite"}),(0,i.kt)("div",{className:"footnotes"},(0,i.kt)("hr",{parentName:"div"}),(0,i.kt)("ol",{parentName:"div"},(0,i.kt)("li",{parentName:"ol",id:"fn-1-82b6b8"},"It's actually too late. I've already made one.",(0,i.kt)("a",{parentName:"li",href:"#fnref-1-82b6b8",className:"footnote-backref"},"\u21a9")))))}g.isMDXComponent=!0},6427:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/header-ab109445239ec9bf6f92e83e301a61b9.jpg"},3058:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/pyramid-cdd04d816a39737a17702602585d3071.jpg"},2462:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/summer_2024-8ce9bdfb83142897515cc43bbcfec074.jpg"},2272:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/header-ab109445239ec9bf6f92e83e301a61b9.jpg"}}]);