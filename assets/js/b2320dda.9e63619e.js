"use strict";(self.webpackChunkchickensoft_site=self.webpackChunkchickensoft_site||[]).push([[547],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),h=a,m=u["".concat(s,".").concat(h)]||u[h]||d[h]||r;return n?o.createElement(m,i(i({ref:t},p),{},{components:n})):o.createElement(m,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<r;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1501:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var o=n(7462),a=(n(7294),n(3905));const r={title:"\ud83e\udd16 Source Generators",image:"./header.jpg"},i=void 0,l={unversionedId:"super_nodes/source_generators",id:"super_nodes/source_generators",title:"\ud83e\udd16 Source Generators",description:"\ud83d\udd04 Lifecycle Hooks",source:"@site/docs/super_nodes/02_source_generators.md",sourceDirName:"super_nodes",slug:"/super_nodes/source_generators",permalink:"/docs/super_nodes/source_generators",draft:!1,editUrl:"https://github.com/chickensoft-games/chickensoft_site/tree/main/docs/super_nodes/02_source_generators.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"\ud83e\udd16 Source Generators",image:"./header.jpg"},sidebar:"tutorialSidebar",previous:{title:"\ud83d\udce6 Installation",permalink:"/docs/super_nodes/installation"},next:{title:"\ud83d\udd75\ufe0f Static Reflection",permalink:"/docs/super_nodes/static_reflection"}},s={image:n(4467).Z},c=[{value:"\ud83d\udd04 Lifecycle Hooks",id:"-lifecycle-hooks",level:2},{value:"\ud83d\ude25 Source Generator Problems",id:"-source-generator-problems",level:2},{value:"\ud83d\udc96 Source Generator Solutions",id:"-source-generator-solutions",level:2},{value:"\ud83d\ude4b Mediators to the Rescue",id:"-mediators-to-the-rescue",level:3},{value:"\ud83c\udfea Guidelines for Source Generator Authors",id:"-guidelines-for-source-generator-authors",level:3}],p={toc:c};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"-lifecycle-hooks"},"\ud83d\udd04 Lifecycle Hooks"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"./"},"Earlier"),', we mentioned that you can declare lifecycle hooks on a SuperNode. In SuperNodes lingo, a "lifecycle hook" is just the name of a method that should be invoked whenever a node lifecycle event occurs, such as ',(0,a.kt)("inlineCode",{parentName:"p"},"Ready"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Process"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"EnterTree"),", etc."),(0,a.kt)("p",null,"Let's explain by showing an example!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'namespace LifecycleExample;\n\nusing Godot;\nusing SuperNodes.Types;\n\n[SuperNode("MyLifecycleHook")]\npublic partial class MySuperNode : Node {\n  public override partial void _Notification(int what);\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"MySuperNode")," class has declared a lifecycle hook named ",(0,a.kt)("inlineCode",{parentName:"p"},"MyLifecycleHook"),". Because we've declared this method, SuperNodes will know to invoke it from its generated implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"_Notification"),"."),(0,a.kt)("p",null,"Here's what the generated code looks like."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"#nullable enable\nusing Godot;\nusing SuperNodes.Types;\n\nnamespace LifecycleExample {\n  partial class MySuperNode {\n    public override partial void _Notification(int what) {\n      // Invoke declared lifecycle method handlers.\n      MyLifecycleHook(what);\n    }\n  }\n}\n#nullable disable\n")),(0,a.kt)("p",null,"Now imagine that we have another source generator that generates a method named ",(0,a.kt)("inlineCode",{parentName:"p"},"MyLifecycleHook")," on our ",(0,a.kt)("inlineCode",{parentName:"p"},"MySuperNode")," class."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'// Pretend this implementation is created by another source generator\npublic partial class MySuperNode {\n  public void MyLifecycleHook(int what) {\n    if (what == NotificationReady) {\n      GD.Print($"{Name} is ready.");\n    }\n  }\n}\n')),(0,a.kt)("p",null,"Even though SuperNodes has no way of knowing about the other source generator, it can still invoke the declared lifecycle hook method!"),(0,a.kt)("p",null,"We can even declare multiple lifecycle method hooks and PowerUps."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'[SuperNode("MyLifecycleHook", typeof(MyPowerUp), "MyOtherLifecycleHook")]\npublic partial class MySuperNode : Node {\n')),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"SuperNodes will invoke lifecycle method hooks and PowerUps in the order that they're declared. In the example above, the invocations will be as follows:"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"// Code generated by SuperNodes\npublic override partial void _Notification(int what) {\n  // Invoke declared lifecycle method handlers.\n  MyLifecycleHook(what);\n  MyPowerUp(what);\n  MyOtherLifecycleHook(what);\n}\n")),(0,a.kt)("p",{parentName:"admonition"},"Lifecycle hooks and PowerUps are always invoked before user-defined lifecycle handlers like ",(0,a.kt)("inlineCode",{parentName:"p"},"OnReady"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"OnProcess"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"OnEnterTree"),", etc.")),(0,a.kt)("h2",{id:"-source-generator-problems"},"\ud83d\ude25 Source Generator Problems"),(0,a.kt)("p",null,"If you've tried to use a third party source generator alongside Godot's official source generators, you may have encountered some of the following limitations:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Since C# source generators don't know each other (by design), the Godot source generators can't generate GDScript bindings for any members added to scripts by other source generators."),(0,a.kt)("p",{parentName:"li"},"Likewise, properties added to script implementations by other source generators will not be exported using the ",(0,a.kt)("inlineCode",{parentName:"p"},"[Export]")," attribute since their generated code is not available to the official Godot source generators."),(0,a.kt)("admonition",{parentName:"li",type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Because the order that source generators run is not configurable in .NET, there is no easy workaround. See ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/godotengine/godot/issues/66597"},"godotengine/godot#66597")," for more details about the perils of source generator support."))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Generated code will be invalid if more than one third-party source generator add the same lifecycle method implementation, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"_Notification"),". Source generators have no way to know if another source generator will implement the same method, so they can't avoid generating duplicate code."))),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"We cannot solve problem #1, but we ",(0,a.kt)("em",{parentName:"p"},"can")," live with it. Essentially, any members added to a class by a third-party source generator will not be visible from Godot or GDScript, but will work just fine in C#. If you're writing code primarily in C#, this will not cause you any issues.")),(0,a.kt)("h2",{id:"-source-generator-solutions"},"\ud83d\udc96 Source Generator Solutions"),(0,a.kt)("p",null,"Theoretically, we ",(0,a.kt)("strong",{parentName:"p"},"can")," solve problem #2."),(0,a.kt)("p",null,"Imagine two source generators that each want to implement ",(0,a.kt)("inlineCode",{parentName:"p"},"_Notification")," to perform actions in response to a node script's lifecycle events. If both generators implement ",(0,a.kt)("inlineCode",{parentName:"p"},"_Notification")," and are added to the game developer's project, the code won't even compile since there will be two duplicate implementations of the ",(0,a.kt)("inlineCode",{parentName:"p"},"_Notification")," method in the same class."),(0,a.kt)("p",null,"So, how do we solve this problem? The same way your parents solved it when you were a kid: by sharing."),(0,a.kt)("h3",{id:"-mediators-to-the-rescue"},"\ud83d\ude4b Mediators to the Rescue"),(0,a.kt)("p",null,"SuperNodes can act as a mediator between source generators. If each generator that wants to tap into a node's lifecycle creates an implementation containing a lifecycle hook method, SuperNodes can invoke each generator's method in the generated ",(0,a.kt)("inlineCode",{parentName:"p"},"_Notification")," method. Afterwards, users can simply add the name of the generator's lifecycle method hook to their ",(0,a.kt)("inlineCode",{parentName:"p"},"[SuperNode]")," attribute to take advantage of the other source generator."),(0,a.kt)("p",null,"For example, imagine we've created a source generator named ",(0,a.kt)("inlineCode",{parentName:"p"},"PrintOnReady")," that generates a method named ",(0,a.kt)("inlineCode",{parentName:"p"},"PrintOnReady")," for each node script. We can then add the ",(0,a.kt)("inlineCode",{parentName:"p"},"PrintOnReady")," lifecycle method name to our ",(0,a.kt)("inlineCode",{parentName:"p"},"[SuperNode]")," attribute to take advantage of the ",(0,a.kt)("inlineCode",{parentName:"p"},"PrintOnReady")," source generator."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'// Hypothetical PrintOnReady source generator output.\npublic partial class MySuperNode {\n  public void PrintOnReady(int what) {\n    if (what == NotificationReady) {\n      GD.Print($"{Name} is ready.");\n    }\n  }\n}\n')),(0,a.kt)("p",null,"In our node script, we can annotate the class with the ",(0,a.kt)("inlineCode",{parentName:"p"},"PrintOnReady")," lifecycle hook method name."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'[SuperNode("PrintOnReady")]\npublic partial class MySuperNode : Node {\n  public override partial void _Notification(int what);\n}\n')),(0,a.kt)("p",null,"That works, but we can do better. Let's use ",(0,a.kt)("inlineCode",{parentName:"p"},"nameof")," to make sure we don't accidentally misspell the lifecycle hook method name!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"[SuperNode(nameof(MySuperNode.PrintOnReady))]\npublic partial class MySuperNode : Node {\n  public override partial void _Notification(int what);\n}\n")),(0,a.kt)("p",null,"Eww, that's kind of long. What if we were using multiple generators?"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"[SuperNode(nameof(MySuperNode.GeneratedMethod1, MySuperNode.GeneratedMethod2))]\npublic partial class MySuperNode : Node {\n")),(0,a.kt)("p",null,"Hmm, that's not so fun."),(0,a.kt)("p",null,"What if the third party source generators injected a class that had the same name as the method it adds to each node script?"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"// Somewhere in the generated code for PrintOnReady\npublic class PrintOnReady {\n  // Nothing to see here \u2014 this only exists to help with nameof!\n}\n")),(0,a.kt)("p",null,"Then we could use ",(0,a.kt)("inlineCode",{parentName:"p"},"nameof")," to get the name of the class, which would be the same as the method."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"[SuperNode(nameof(PrintOnReady))]\npublic partial class MySuperNode : Node {\n")),(0,a.kt)("p",null,"Ah, perfect. We've essentially developed a convention that third party source generators can follow if they want to work together in harmony by allowing SuperNodes to mediate for them."),(0,a.kt)("h3",{id:"-guidelines-for-source-generator-authors"},"\ud83c\udfea Guidelines for Source Generator Authors"),(0,a.kt)("p",null,"Are you a source generator author? Do you want to make a compatible source generator that taps into a Godot node's lifecycle and plays nicely with other generators using SuperNodes? If so, here are Chickensoft's official guidelines to help you get started:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u2611\ufe0f Source generators should inject a class with the same name as the lifecycle hook method it intends to add to a node script."),(0,a.kt)("p",{parentName:"li"},"If a source generator wants to add different kinds of lifecycle hook methods (depending on the node), it can inject a class for each method name it might add. Injecting a class name is helpful to allow users to easily reference the name of the method in the ",(0,a.kt)("inlineCode",{parentName:"p"},"[SuperNode]")," attribute using ",(0,a.kt)("inlineCode",{parentName:"p"},"nameof")," in a type-safe way.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u2611\ufe0f Prefer lifecycle method hook names that match the name of the generator so that users can more easily discover the method name via autocomplete.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u2611\ufe0f Don't implement other lifecycle methods, like ",(0,a.kt)("inlineCode",{parentName:"p"},"_Notification"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"_Ready"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"_Process"),", etc. The generator's lifecycle method hook will be invoked whenever any event occurs, allowing the generator to filter out the events it cares about.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u2611\ufe0f In the documentation/README for the source generator, please include a note that explains their users must also reference SuperNodes for the generator to be invoked in response to lifecycle events."))),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"If you're working on a source generator, get in touch with us on ",(0,a.kt)("a",{parentName:"p",href:"https://discord.gg/gSjaPgMmYW"},"Discord"),"! We'd love to answer any questions you have, as well as give you a place to share your tool with the community!")))}d.isMDXComponent=!0},4467:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/header-bbf251851f04eefa5fd63323124240f2.jpg"}}]);