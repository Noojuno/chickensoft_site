"use strict";(self.webpackChunkchickensoft_site=self.webpackChunkchickensoft_site||[]).push([[9769],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=o.createContext({}),s=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return o.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=s(n),m=a,h=d["".concat(c,".").concat(m)]||d[m]||p[m]||r;return n?o.createElement(h,i(i({ref:t},u),{},{components:n})):o.createElement(h,i({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5079:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var o=n(7462),a=(n(7294),n(3905));const r={title:"\u23f3 Countdown",image:"../header.jpg"},i=void 0,l={unversionedId:"logic_blocks/tutorial/coundown",id:"logic_blocks/tutorial/coundown",title:"\u23f3 Countdown",description:"Now that our timer can be turned on, off, and set to a given duration, it's time to make it actually work.",source:"@site/docs/logic_blocks/05_tutorial/03_coundown.md",sourceDirName:"logic_blocks/05_tutorial",slug:"/logic_blocks/tutorial/coundown",permalink:"/docs/logic_blocks/tutorial/coundown",draft:!1,editUrl:"https://github.com/chickensoft-games/chickensoft_site/tree/main/docs/logic_blocks/05_tutorial/03_coundown.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"\u23f3 Countdown",image:"../header.jpg"},sidebar:"tutorialSidebar",previous:{title:"\ud83d\udd06 Power",permalink:"/docs/logic_blocks/tutorial/power"},next:{title:"\u23f0 Beeping",permalink:"/docs/logic_blocks/tutorial/beeping"}},c={},s=[],u={toc:s};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Now that our timer can be turned on, off, and set to a given duration, it's time to make it actually work."),(0,a.kt)("p",null,"We could build the timer in a really simple fashion, but in the interest of actually learning something, let's pretend that our project has a clock service that exposes an ",(0,a.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events/"},"event")," that informs us when a second has passed, roughly speaking."),(0,a.kt)("p",null,"In this section, we'll make our new ",(0,a.kt)("inlineCode",{parentName:"p"},"Countdown")," state subscribe to the clock service and respond to a new ",(0,a.kt)("inlineCode",{parentName:"p"},"TimeElapsed")," input."),(0,a.kt)("p",null,"First, let's define what the clock service looks like."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"/// <summary>\n/// A service that announces the passage of time, roughly once per second.\n/// </summary>\npublic interface IClock {\n  /// <summary>\n  /// Invoked about every second or so. Provides the time since the last\n  /// invocation (in seconds).\n  /// </summary>\n  event Action<double> TimeElapsed;\n}\n")),(0,a.kt)("p",null,"Easy enough. Let's make a new ",(0,a.kt)("inlineCode",{parentName:"p"},"Countdown")," state. We can register ",(0,a.kt)("a",{parentName:"p",href:"../basics/states#%EF%B8%8F-attachment"},"attach and detach callbacks")," to subscribe to the clock service whenever the ",(0,a.kt)("inlineCode",{parentName:"p"},"Countdown")," state becomes the active state, and unsubscribe when it is no longer the active state."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public static class Input {\n  public readonly record struct PowerButtonPressed;\n  public readonly record struct ChangeDuration(double Duration);\n  public readonly record struct StartStopButtonPressed;\n  public readonly record struct TimeElapsed(double Delta);\n}\n\npublic record Countdown : PoweredOn, IGet<Input.TimeElapsed>, IGet<Input.StartStopButtonPressed> {\n  public Countdown() {\n    OnAttach(() => Get<IClock>().TimeElapsed += OnTimeElapsed);\n    OnDetach(() => Get<IClock>().TimeElapsed -= OnTimeElapsed);\n  }\n\n  private void OnTimeElapsed(double delta) =>\n    Input(new Input.TimeElapsed(delta));\n\n  public Transition On(in Input.TimeElapsed input) {\n    var data = Get<Data>();\n    data.TimeRemaining -= input.Delta;\n    return data.TimeRemaining <= 0.0d ? To<Beeping>() : ToSelf();\n  }\n\n  public Transition On(in Input.StartStopButtonPressed input) => To<Idle>();\n}\n")),(0,a.kt)("p",null,"We access the clock service through the blackboard when we're attaching/detaching so that we can subscribe and unsubscribe to it."),(0,a.kt)("p",null,"We've also added a private method in ",(0,a.kt)("inlineCode",{parentName:"p"},"Countdown")," that adds an input to the logic block whenever the clock invokes the ",(0,a.kt)("inlineCode",{parentName:"p"},"TimeElapsed")," event."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"private void OnTimeElapsed(double delta) =>\n  Input(new Input.TimeElapsed(delta));\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Input()")," method allows us to add an input on the logic block we are attached to. Since we unsubscribe when we're detached, this method will only ever get called when the ",(0,a.kt)("inlineCode",{parentName:"p"},"Countdown")," state is active."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"By subscribing to an event and adding an input to ourselves, we can force a state change to occur. This pattern of forcing state changes through subscriptions and inputs allows us to react to external events without creating a mess of our code.")),(0,a.kt)("p",null,"Finally, in our input handler for the ",(0,a.kt)("inlineCode",{parentName:"p"},"TimeElapsed")," input that we add to ourselves whenever the clock we're subscribed to invokes its ",(0,a.kt)("inlineCode",{parentName:"p"},"TimeElapsed")," event, we decrement the time remaining and transition to the ",(0,a.kt)("inlineCode",{parentName:"p"},"Beeping")," state when the time runs out."),(0,a.kt)("p",null,"We don't have a beeping state yet, so we'll go ahead and create one in the next section."))}p.isMDXComponent=!0}}]);